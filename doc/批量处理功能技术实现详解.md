# æ‰¹é‡å¤„ç†åŠŸèƒ½æŠ€æœ¯å®ç°è¯¦è§£ (.NET 10 + C# 14)

## ğŸ“‹ ç›®å½•

1. [åŠŸèƒ½æ¦‚è¿°](#åŠŸèƒ½æ¦‚è¿°)
2. [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
3. [ViewModel å±‚å®ç°](#viewmodel-å±‚å®ç°)
4. [View å±‚å®ç°](#view-å±‚å®ç°)
5. [å¼‚æ­¥å¤„ç†æ¨¡å¼](#å¼‚æ­¥å¤„ç†æ¨¡å¼)
6. [æ•°æ®åˆå¹¶ç®—æ³•](#æ•°æ®åˆå¹¶ç®—æ³•)
7. [UI è¿›åº¦åé¦ˆ](#ui-è¿›åº¦åé¦ˆ)
8. [æ–‡ä»¶ç³»ç»Ÿæ“ä½œ](#æ–‡ä»¶ç³»ç»Ÿæ“ä½œ)
9. [é”™è¯¯å¤„ç†æœºåˆ¶](#é”™è¯¯å¤„ç†æœºåˆ¶)
10. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
11. [æµ‹è¯•ä¸éªŒè¯](#æµ‹è¯•ä¸éªŒè¯)

---

## ğŸ¯ åŠŸèƒ½æ¦‚è¿°

### æ ¸å¿ƒåŠŸèƒ½
- **æ‰¹é‡æ–‡ä»¶æ‰«æ**ï¼šé€’å½’æ‰«ææŒ‡å®šæ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰ `.txt` æ–‡ä»¶
- **å¹¶è¡Œå¤„ç†**ï¼šå¼‚æ­¥å¤„ç†å¤šä¸ªæ–‡ä»¶ï¼Œæé«˜å¤„ç†æ•ˆç‡
- **æ•°æ®åˆå¹¶**ï¼šæ™ºèƒ½åˆå¹¶æ¥è‡ªä¸åŒæ–‡ä»¶çš„æ ‡ç­¾ç»Ÿè®¡ç»“æœ
- **è¿›åº¦åé¦ˆ**ï¼šå®æ—¶æ˜¾ç¤ºå¤„ç†è¿›åº¦å’Œå½“å‰çŠ¶æ€
- **æ¥æºè¿½è¸ª**ï¼šè®°å½•æ¯ä¸ªæ ‡ç­¾æ¥è‡ªå“ªäº›æ–‡ä»¶å’ŒID

### æŠ€æœ¯ç‰¹ç‚¹
- ä½¿ç”¨ C# 14 æœ€æ–°è¯­æ³•ç‰¹æ€§
- åŸºäº .NET 10 å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼
- Avalonia UI ç°ä»£åŒ–ç•Œé¢
- MVVM æ¶æ„æ¨¡å¼
- å†…å­˜é«˜æ•ˆçš„æ•°æ®å¤„ç†

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ‰¹é‡å¤„ç†æ¶æ„è®¾è®¡                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Presentation Layer (è¡¨ç¤ºå±‚)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   MainWindow    â”‚  â”‚   ProgressBar   â”‚  â”‚   StatusUI   â”‚ â”‚
â”‚  â”‚   (ä¸»ç•Œé¢)       â”‚  â”‚   (è¿›åº¦æ¡)      â”‚  â”‚   (çŠ¶æ€æ˜¾ç¤º)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Business Logic Layer (ä¸šåŠ¡é€»è¾‘å±‚)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ MainWindowVM    â”‚  â”‚ BatchProcessor  â”‚  â”‚ DataMerger   â”‚ â”‚
â”‚  â”‚ (ä¸»è§†å›¾æ¨¡å‹)     â”‚  â”‚ (æ‰¹é‡å¤„ç†å™¨)    â”‚  â”‚ (æ•°æ®åˆå¹¶å™¨)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Access Layer (æ•°æ®è®¿é—®å±‚)                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   FileScanner   â”‚  â”‚   TextParser    â”‚  â”‚   TagInfo    â”‚ â”‚
â”‚  â”‚   (æ–‡ä»¶æ‰«æå™¨)   â”‚  â”‚   (æ–‡æœ¬è§£æå™¨)   â”‚  â”‚   (æ ‡ç­¾ä¿¡æ¯)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Infrastructure Layer (åŸºç¡€è®¾æ–½å±‚)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   FileSystem    â”‚  â”‚   Async/Await   â”‚  â”‚   Progress   â”‚ â”‚
â”‚  â”‚   (æ–‡ä»¶ç³»ç»Ÿ)     â”‚  â”‚   (å¼‚æ­¥å¤„ç†)    â”‚  â”‚   (è¿›åº¦è·Ÿè¸ª)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ•°æ®æµè®¾è®¡

```
æ–‡ä»¶å¤¹é€‰æ‹© â†’ æ–‡ä»¶æ‰«æ â†’ å¼‚æ­¥å¤„ç† â†’ æ•°æ®åˆå¹¶ â†’ UIæ›´æ–°
     â†“           â†“          â†“         â†“        â†“
  ç”¨æˆ·æ“ä½œ   é€’å½’æ‰«æ    å¹¶è¡Œè§£æ    æ™ºèƒ½åˆå¹¶   å®æ—¶åé¦ˆ
     â†“           â†“          â†“         â†“        â†“
  æ–‡ä»¶å¤¹è·¯å¾„  .txtæ–‡ä»¶åˆ—è¡¨  æ ‡ç­¾æ•°æ®   åˆå¹¶ç»“æœ   è¿›åº¦æ˜¾ç¤º
```

---

## ğŸ“Š ViewModel å±‚å®ç°

### 1. æ ¸å¿ƒå±æ€§è®¾è®¡

```csharp
// ViewModels/MainWindowViewModel.cs
public class MainWindowViewModel : INotifyPropertyChanged
{
    // åŸºç¡€å±æ€§
    private ObservableCollection<TagInfoViewModel> _tagInfos = new();
    private string _statusMessage = "è¯·é€‰æ‹©æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹è¿›è¡Œåˆ†æ";
    private bool _isProcessing = false;
    
    // æ‰¹é‡å¤„ç†ä¸“ç”¨å±æ€§
    private int _processedFiles = 0;
    private int _totalFiles = 0;
    private string _currentProcessingFile = string.Empty;
    
    // å±æ€§å®ç°
    public ObservableCollection<TagInfoViewModel> TagInfos
    {
        get => _tagInfos;
        set { _tagInfos = value; OnPropertyChanged(); }
    }
    
    public int ProcessedFiles
    {
        get => _processedFiles;
        set
        {
            _processedFiles = value;
            OnPropertyChanged();
            OnPropertyChanged(nameof(ProgressMessage)); // è§¦å‘è®¡ç®—å±æ€§æ›´æ–°
        }
    }
    
    public int TotalFiles
    {
        get => _totalFiles;
        set
        {
            _totalFiles = value;
            OnPropertyChanged();
            OnPropertyChanged(nameof(ProgressMessage));
        }
    }
    
    // è®¡ç®—å±æ€§ - C# 14 ç‰¹æ€§
    public string ProgressMessage
    {
        get
        {
            if (_totalFiles > 0)
            {
                return $"è¿›åº¦: {_processedFiles}/{_totalFiles} ({_processedFiles * 100.0 / _totalFiles:F1}%)";
            }
            return string.Empty;
        }
    }
}
```

### 2. æ‰¹é‡å¤„ç†æ–¹æ³•å®ç°

```csharp
// æ‰¹é‡å¤„ç†æ ¸å¿ƒæ–¹æ³•
public async Task ProcessFolderAsync(string folderPath)
{
    IsProcessing = true;
    StatusMessage = "æ­£åœ¨æ‰«ææ–‡ä»¶å¤¹...";
    ProcessedFiles = 0;
    TotalFiles = 0;

    try
    {
        // 1. æ–‡ä»¶æ‰«æé˜¶æ®µ
        var txtFiles = Directory.GetFiles(folderPath, "*.txt", SearchOption.AllDirectories);
        TotalFiles = txtFiles.Length;

        if (TotalFiles == 0)
        {
            StatusMessage = "æ–‡ä»¶å¤¹ä¸­æ²¡æœ‰æ‰¾åˆ°txtæ–‡ä»¶";
            return;
        }

        StatusMessage = $"æ‰¾åˆ° {TotalFiles} ä¸ªtxtæ–‡ä»¶ï¼Œå¼€å§‹æ‰¹é‡å¤„ç†...";

        // 2. æ•°æ®åˆå¹¶å®¹å™¨
        var allTagInfos = new Dictionary<string, TagInfoViewModel>();

        // 3. é€ä¸ªæ–‡ä»¶å¤„ç†
        foreach (var filePath in txtFiles)
        {
            try
            {
                // æ›´æ–°å½“å‰å¤„ç†æ–‡ä»¶
                CurrentProcessingFile = Path.GetFileName(filePath);
                StatusMessage = $"æ­£åœ¨å¤„ç†: {CurrentProcessingFile}";

                // å¼‚æ­¥è¯»å–æ–‡ä»¶å†…å®¹
                var content = await File.ReadAllTextAsync(filePath);
                var results = TextParser.ParseText(content);

                // åˆå¹¶ç»“æœåˆ°æ€»å®¹å™¨
                MergeResults(allTagInfos, results, filePath);
            }
            catch (Exception ex)
            {
                StatusMessage = $"å¤„ç†æ–‡ä»¶ {Path.GetFileName(filePath)} å¤±è´¥: {ex.Message}";
            }

            // æ›´æ–°è¿›åº¦
            ProcessedFiles++;
        }

        // 4. æ›´æ–°UIæ˜¾ç¤º
        UpdateUIWithResults(allTagInfos);
        StatusMessage = $"æ‰¹é‡å¤„ç†å®Œæˆï¼å…±å¤„ç† {ProcessedFiles} ä¸ªæ–‡ä»¶ï¼Œæ‰¾åˆ° {allTagInfos.Count} ä¸ªä¸åŒçš„æ ‡ç­¾";
    }
    catch (Exception ex)
    {
        StatusMessage = $"æ‰¹é‡å¤„ç†å¤±è´¥ï¼š{ex.Message}";
    }
    finally
    {
        IsProcessing = false;
        CurrentProcessingFile = string.Empty;
    }
}
```

### 3. æ•°æ®åˆå¹¶ç®—æ³•

```csharp
// æ™ºèƒ½æ•°æ®åˆå¹¶æ–¹æ³•
private void MergeResults(Dictionary<string, TagInfoViewModel> allTagInfos, 
                         List<TagInfo> results, string filePath)
{
    foreach (var result in results)
    {
        if (!allTagInfos.ContainsKey(result.Tag))
        {
            // åˆ›å»ºæ–°çš„æ ‡ç­¾ä¿¡æ¯
            allTagInfos[result.Tag] = new TagInfoViewModel
            {
                Tag = result.Tag,
                Count = 0,
                SourceIds = string.Empty,
                SourceFiles = string.Empty
            };
        }

        // ç´¯åŠ è®¡æ•°
        allTagInfos[result.Tag].Count += result.Count;
        
        // åˆå¹¶æ¥æºID - ä½¿ç”¨ C# 14 é›†åˆè¡¨è¾¾å¼
        var existingIds = allTagInfos[result.Tag].SourceIds
            .Split(", ", StringSplitOptions.RemoveEmptyEntries)
            .ToList();
        existingIds.AddRange(result.SourceIds);
        allTagInfos[result.Tag].SourceIds = string.Join(", ", existingIds.Distinct());

        // æ·»åŠ æ–‡ä»¶ä¿¡æ¯
        var fileName = Path.GetFileName(filePath);
        if (!string.IsNullOrEmpty(allTagInfos[result.Tag].SourceFiles))
        {
            allTagInfos[result.Tag].SourceFiles += $", {fileName}";
        }
        else
        {
            allTagInfos[result.Tag].SourceFiles = fileName;
        }
    }
}

// UIæ›´æ–°æ–¹æ³•
private void UpdateUIWithResults(Dictionary<string, TagInfoViewModel> allTagInfos)
{
    TagInfos.Clear();
    foreach (var tagInfo in allTagInfos.Values.OrderBy(t => t.Tag))
    {
        TagInfos.Add(tagInfo);
    }
}
```

---

## ğŸ–¥ï¸ View å±‚å®ç°

### 1. XAML ç•Œé¢è®¾è®¡

```xml
<!-- MainWindow.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:TagAnalyzer.ViewModels"
        x:Class="TagAnalyzer.MainWindow"
        x:DataType="vm:MainWindowViewModel"
        Title="æ ‡ç­¾åˆ†æå·¥å…· - æ‰¹é‡å¤„ç†ç‰ˆ - jiashuai_xu@qq.com"
        Width="1000" Height="800"
        MinWidth="800" MinHeight="600">

    <Grid RowDefinitions="Auto,*,Auto">
        <!-- å·¥å…·æ  -->
        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="10" Spacing="10">
            <Button Name="SelectFileButton" Content="é€‰æ‹©æ–‡ä»¶" 
                    Click="SelectFileButton_Click"
                    IsEnabled="{Binding !IsProcessing}"
                    Classes="accent"/>
            <Button Name="SelectFolderButton" Content="é€‰æ‹©æ–‡ä»¶å¤¹" 
                    Click="SelectFolderButton_Click"
                    IsEnabled="{Binding !IsProcessing}"
                    Classes="accent"/>
            <Button Name="ExportCsvButton" Content="å¯¼å‡ºCSV" 
                    Click="ExportCsvButton_Click"
                    Classes="outline"/>
            <Button Name="ClearButton" Content="æ¸…ç©ºç»“æœ" 
                    Click="ClearButton_Click"
                    Classes="outline"/>
        </StackPanel>

        <!-- ä¸»å†…å®¹åŒºåŸŸ -->
        <Grid Grid.Row="1" Margin="10">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>

            <!-- çŠ¶æ€ä¿¡æ¯åŒºåŸŸ -->
            <StackPanel Grid.Row="0" Margin="0,0,0,10">
                <!-- ä¸»çŠ¶æ€ä¿¡æ¯ -->
                <TextBlock Text="{Binding StatusMessage}" 
                           FontSize="14" 
                           Foreground="{DynamicResource SystemAccentColor}"/>
                
                <!-- è¿›åº¦ä¿¡æ¯ -->
                <StackPanel Orientation="Horizontal" Margin="0,5,0,0" 
                            IsVisible="{Binding TotalFiles}">
                    <TextBlock Text="{Binding ProgressMessage}" 
                               FontSize="12" 
                               Foreground="{DynamicResource SystemBaseMediumColor}"/>
                    <TextBlock Text="{Binding CurrentProcessingFile, StringFormat=' | å½“å‰: {0}'}" 
                               FontSize="12" 
                               Foreground="{DynamicResource SystemBaseMediumColor}"
                               Margin="10,0,0,0"/>
                </StackPanel>
                
                <!-- è¿›åº¦æ¡ -->
                <ProgressBar Value="{Binding ProcessedFiles}" 
                             Maximum="{Binding TotalFiles}"
                             IsVisible="{Binding TotalFiles}"
                             Margin="0,5,0,0"/>
            </StackPanel>

            <!-- æ•°æ®è¡¨æ ¼ -->
            <ListBox Grid.Row="1" 
                     ItemsSource="{Binding TagInfos}"
                     ScrollViewer.HorizontalScrollBarVisibility="Auto"
                     ScrollViewer.VerticalScrollBarVisibility="Auto">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <Grid Margin="5">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="120"/>
                                <ColumnDefinition Width="80"/>
                                <ColumnDefinition Width="200"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>
                            <TextBlock Grid.Column="0" Text="{Binding Tag}" FontWeight="Bold"/>
                            <TextBlock Grid.Column="1" Text="{Binding Count}" HorizontalAlignment="Center"/>
                            <TextBlock Grid.Column="2" Text="{Binding SourceIds}" TextWrapping="Wrap" FontSize="11"/>
                            <TextBlock Grid.Column="3" Text="{Binding SourceFiles}" TextWrapping="Wrap" FontSize="11" 
                                       Foreground="{DynamicResource SystemBaseMediumColor}"/>
                        </Grid>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>
        </Grid>

        <!-- åº•éƒ¨çŠ¶æ€æ  -->
        <Border Grid.Row="2" Background="{DynamicResource SystemControlBackgroundBaseLowBrush}" 
                Padding="10,5">
            <TextBlock Text="å¼€å‘è€…: jiashuai_xu@qq.com | ç‰ˆæœ¬: 1.0.0 | æ”¯æŒæ‰¹é‡å¤„ç†" 
                       HorizontalAlignment="Right"/>
        </Border>
    </Grid>
</Window>
```

### 2. ä»£ç åå°å®ç°

```csharp
// MainWindow.axaml.cs
public partial class MainWindow : Window
{
    private readonly MainWindowViewModel _viewModel;

    public MainWindow()
    {
        InitializeComponent();
        _viewModel = new MainWindowViewModel();
        DataContext = _viewModel;
    }

    // æ–‡ä»¶å¤¹é€‰æ‹©äº‹ä»¶å¤„ç†
    private async void SelectFolderButton_Click(object? sender, RoutedEventArgs e)
    {
        try
        {
            var options = new FolderPickerOpenOptions
            {
                Title = "é€‰æ‹©åŒ…å«txtæ–‡ä»¶çš„æ–‡ä»¶å¤¹",
                AllowMultiple = false
            };

            var folders = await StorageProvider.OpenFolderPickerAsync(options);
            
            if (folders.Count > 0)
            {
                var folder = folders[0];
                await _viewModel.ProcessFolderAsync(folder.Path.LocalPath);
            }
        }
        catch (Exception ex)
        {
            _viewModel.StatusMessage = $"æ–‡ä»¶å¤¹å¤„ç†å¤±è´¥ï¼š{ex.Message}";
        }
    }

    // å¢å¼ºçš„CSVå¯¼å‡º
    private async void ExportCsvButton_Click(object? sender, RoutedEventArgs e)
    {
        try
        {
            var options = new FilePickerSaveOptions
            {
                Title = "ä¿å­˜CSVæ–‡ä»¶",
                DefaultExtension = "csv",
                FileTypeChoices = new[]
                {
                    new FilePickerFileType("CSVæ–‡ä»¶")
                    {
                        Patterns = new[] { "*.csv" }
                    }
                }
            };

            var file = await StorageProvider.SaveFilePickerAsync(options);
            
            if (file != null)
            {
                await using var writer = new StreamWriter(file.Path.LocalPath);
                await using var csv = new CsvWriter(writer, System.Globalization.CultureInfo.InvariantCulture);
                
                // å†™å…¥æ ‡é¢˜ - åŒ…å«æ¥æºæ–‡ä»¶åˆ—
                csv.WriteField("æ ‡ç­¾");
                csv.WriteField("å‡ºç°æ¬¡æ•°");
                csv.WriteField("æ¥æºID");
                csv.WriteField("æ¥æºæ–‡ä»¶");
                await csv.NextRecordAsync();

                // å†™å…¥æ•°æ®
                foreach (var tagInfo in _viewModel.TagInfos)
                {
                    csv.WriteField(tagInfo.Tag);
                    csv.WriteField(tagInfo.Count);
                    csv.WriteField(tagInfo.SourceIds);
                    csv.WriteField(tagInfo.SourceFiles);
                    await csv.NextRecordAsync();
                }

                _viewModel.StatusMessage = $"CSVæ–‡ä»¶å·²ä¿å­˜åˆ°ï¼š{file.Path.LocalPath}";
            }
        }
        catch (Exception ex)
        {
            _viewModel.StatusMessage = $"CSVå¯¼å‡ºå¤±è´¥ï¼š{ex.Message}";
        }
    }
}
```

---

## âš¡ å¼‚æ­¥å¤„ç†æ¨¡å¼

### 1. ç°ä»£å¼‚æ­¥æ¨¡å¼

```csharp
// ä½¿ç”¨ C# 14 ç°ä»£å¼‚æ­¥æ¨¡å¼
public async Task ProcessFolderAsync(string folderPath)
{
    // ä½¿ç”¨ ConfigureAwait(false) ä¼˜åŒ–
    await using var cancellationTokenSource = new CancellationTokenSource();
    
    try
    {
        // å¼‚æ­¥æ–‡ä»¶æ‰«æ
        var txtFiles = await Task.Run(() => 
            Directory.GetFiles(folderPath, "*.txt", SearchOption.AllDirectories),
            cancellationTokenSource.Token);
        
        // å¹¶è¡Œå¤„ç†æ–‡ä»¶ - å¯é€‰ä¼˜åŒ–
        var tasks = txtFiles.Select(async filePath =>
        {
            try
            {
                var content = await File.ReadAllTextAsync(filePath, cancellationTokenSource.Token);
                return new { FilePath = filePath, Content = content };
            }
            catch (Exception ex)
            {
                return new { FilePath = filePath, Content = (string?)null, Error = ex.Message };
            }
        });
        
        var results = await Task.WhenAll(tasks);
        
        // å¤„ç†ç»“æœ
        foreach (var result in results)
        {
            if (result.Content != null)
            {
                // å¤„ç†æˆåŠŸ
                ProcessFileContent(result.FilePath, result.Content);
            }
            else
            {
                // å¤„ç†å¤±è´¥
                HandleFileError(result.FilePath, result.Error);
            }
        }
    }
    catch (OperationCanceledException)
    {
        StatusMessage = "å¤„ç†å·²å–æ¶ˆ";
    }
}
```

### 2. å¼‚æ­¥æµæ¨¡å¼ (IAsyncEnumerable)

```csharp
// ä½¿ç”¨å¼‚æ­¥æµå¤„ç†å¤§é‡æ–‡ä»¶
public async IAsyncEnumerable<ProcessResult> ProcessFilesAsync(
    IEnumerable<string> filePaths,
    [EnumeratorCancellation] CancellationToken cancellationToken = default)
{
    foreach (var filePath in filePaths)
    {
        cancellationToken.ThrowIfCancellationRequested();
        
        try
        {
            var content = await File.ReadAllTextAsync(filePath, cancellationToken);
            var tags = TextParser.ParseText(content);
            
            yield return new ProcessResult
            {
                FilePath = filePath,
                Tags = tags,
                Success = true
            };
        }
        catch (Exception ex)
        {
            yield return new ProcessResult
            {
                FilePath = filePath,
                Error = ex.Message,
                Success = false
            };
        }
    }
}

// ä½¿ç”¨å¼‚æ­¥æµ
public async Task ProcessFolderWithAsyncStream(string folderPath)
{
    var txtFiles = Directory.GetFiles(folderPath, "*.txt", SearchOption.AllDirectories);
    
    await foreach (var result in ProcessFilesAsync(txtFiles))
    {
        if (result.Success)
        {
            // å¤„ç†æˆåŠŸçš„ç»“æœ
            MergeResults(result.Tags, result.FilePath);
        }
        else
        {
            // å¤„ç†é”™è¯¯
            StatusMessage = $"å¤„ç†æ–‡ä»¶ {result.FilePath} å¤±è´¥: {result.Error}";
        }
        
        ProcessedFiles++;
    }
}
```

---

## ğŸ”„ æ•°æ®åˆå¹¶ç®—æ³•

### 1. é«˜æ•ˆåˆå¹¶ç­–ç•¥

```csharp
// ä½¿ç”¨ C# 14 é›†åˆè¡¨è¾¾å¼å’Œæ¨¡å¼åŒ¹é…
public class DataMerger
{
    private readonly Dictionary<string, TagInfoViewModel> _tagDictionary = new();
    
    public void MergeTagData(IEnumerable<TagInfo> newTags, string sourceFile)
    {
        foreach (var tag in newTags)
        {
            // ä½¿ç”¨æ¨¡å¼åŒ¹é…å¤„ç†ä¸åŒæƒ…å†µ
            var result = tag switch
            {
                { Tag: var tagName, Count: > 0 } when !string.IsNullOrEmpty(tagName) =>
                    ProcessValidTag(tagName, tag.Count, sourceFile),
                { Tag: "" } => 
                    HandleEmptyTag(),
                _ => 
                    HandleInvalidTag(tag)
            };
            
            if (result != null)
            {
                UpdateTagDictionary(result);
            }
        }
    }
    
    private TagInfoViewModel ProcessValidTag(string tagName, int count, string sourceFile)
    {
        if (!_tagDictionary.ContainsKey(tagName))
        {
            _tagDictionary[tagName] = new TagInfoViewModel
            {
                Tag = tagName,
                Count = 0,
                SourceIds = string.Empty,
                SourceFiles = string.Empty
            };
        }
        
        var existing = _tagDictionary[tagName];
        existing.Count += count;
        
        // ä½¿ç”¨ C# 14 é›†åˆè¡¨è¾¾å¼æ›´æ–°æ¥æº
        UpdateSourceInfo(existing, sourceFile);
        
        return existing;
    }
    
    private void UpdateSourceInfo(TagInfoViewModel tagInfo, string sourceFile)
    {
        var fileName = Path.GetFileName(sourceFile);
        
        // ä½¿ç”¨é›†åˆè¡¨è¾¾å¼å¤„ç†æ¥æºæ–‡ä»¶
        var sourceFiles = tagInfo.SourceFiles
            .Split(", ", StringSplitOptions.RemoveEmptyEntries)
            .ToList();
            
        if (!sourceFiles.Contains(fileName))
        {
            sourceFiles.Add(fileName);
            tagInfo.SourceFiles = string.Join(", ", sourceFiles);
        }
    }
}
```

### 2. å†…å­˜ä¼˜åŒ–åˆå¹¶

```csharp
// å†…å­˜é«˜æ•ˆçš„æ‰¹é‡åˆå¹¶
public class MemoryEfficientMerger
{
    public Dictionary<string, TagInfoViewModel> MergeBatchResults(
        IEnumerable<(string FilePath, List<TagInfo> Tags)> batchResults)
    {
        var result = new Dictionary<string, TagInfoViewModel>();
        
        foreach (var (filePath, tags) in batchResults)
        {
            var fileName = Path.GetFileName(filePath);
            
            foreach (var tag in tags)
            {
                if (!result.ContainsKey(tag.Tag))
                {
                    result[tag.Tag] = new TagInfoViewModel
                    {
                        Tag = tag.Tag,
                        Count = 0,
                        SourceIds = string.Empty,
                        SourceFiles = string.Empty
                    };
                }
                
                var existing = result[tag.Tag];
                existing.Count += tag.Count;
                
                // é«˜æ•ˆåˆå¹¶æ¥æºID
                MergeSourceIds(existing, tag.SourceIds);
                
                // é«˜æ•ˆåˆå¹¶æ¥æºæ–‡ä»¶
                MergeSourceFiles(existing, fileName);
            }
        }
        
        return result;
    }
    
    private void MergeSourceIds(TagInfoViewModel existing, List<string> newIds)
    {
        if (string.IsNullOrEmpty(existing.SourceIds))
        {
            existing.SourceIds = string.Join(", ", newIds);
        }
        else
        {
            var existingIds = existing.SourceIds.Split(", ").ToHashSet();
            existingIds.UnionWith(newIds);
            existing.SourceIds = string.Join(", ", existingIds);
        }
    }
    
    private void MergeSourceFiles(TagInfoViewModel existing, string fileName)
    {
        if (string.IsNullOrEmpty(existing.SourceFiles))
        {
            existing.SourceFiles = fileName;
        }
        else if (!existing.SourceFiles.Contains(fileName))
        {
            existing.SourceFiles += $", {fileName}";
        }
    }
}
```

---

## ğŸ“Š UI è¿›åº¦åé¦ˆ

### 1. å®æ—¶è¿›åº¦æ›´æ–°

```csharp
// è¿›åº¦åé¦ˆæœºåˆ¶
public class ProgressReporter
{
    private readonly MainWindowViewModel _viewModel;
    private readonly Timer _progressTimer;
    
    public ProgressReporter(MainWindowViewModel viewModel)
    {
        _viewModel = viewModel;
        _progressTimer = new Timer(UpdateProgress, null, 0, 100); // æ¯100msæ›´æ–°ä¸€æ¬¡
    }
    
    private void UpdateProgress(object? state)
    {
        if (_viewModel.IsProcessing)
        {
            // è®¡ç®—å¤„ç†é€Ÿåº¦
            var elapsed = DateTime.Now - _viewModel.StartTime;
            var filesPerSecond = _viewModel.ProcessedFiles / elapsed.TotalSeconds;
            
            // ä¼°ç®—å‰©ä½™æ—¶é—´
            var remainingFiles = _viewModel.TotalFiles - _viewModel.ProcessedFiles;
            var estimatedTime = TimeSpan.FromSeconds(remainingFiles / filesPerSecond);
            
            // æ›´æ–°çŠ¶æ€ä¿¡æ¯
            _viewModel.StatusMessage = $"å¤„ç†ä¸­... é€Ÿåº¦: {filesPerSecond:F1} æ–‡ä»¶/ç§’, é¢„è®¡å‰©ä½™: {estimatedTime:mm\\:ss}";
        }
    }
    
    public void Dispose()
    {
        _progressTimer?.Dispose();
    }
}
```

### 2. è¿›åº¦æ¡åŠ¨ç”»

```xml
<!-- å¸¦åŠ¨ç”»çš„è¿›åº¦æ¡ -->
<ProgressBar Value="{Binding ProcessedFiles}" 
             Maximum="{Binding TotalFiles}"
             IsVisible="{Binding TotalFiles}"
             Margin="0,5,0,0">
    <ProgressBar.Styles>
        <Style Selector="ProgressBar">
            <Setter Property="Background" Value="{DynamicResource SystemControlBackgroundBaseLowBrush}"/>
            <Setter Property="Foreground" Value="{DynamicResource SystemAccentColor}"/>
            <Setter Property="Height" Value="8"/>
            <Setter Property="CornerRadius" Value="4"/>
        </Style>
    </ProgressBar.Styles>
</ProgressBar>
```

---

## ğŸ“ æ–‡ä»¶ç³»ç»Ÿæ“ä½œ

### 1. é«˜æ•ˆæ–‡ä»¶æ‰«æ

```csharp
// ä½¿ç”¨ C# 14 ç°ä»£æ–‡ä»¶ç³»ç»Ÿæ“ä½œ
public class FileScanner
{
    public async Task<List<string>> ScanTxtFilesAsync(string folderPath, 
        CancellationToken cancellationToken = default)
    {
        var files = new List<string>();
        
        try
        {
            // ä½¿ç”¨å¼‚æ­¥æšä¸¾
            await foreach (var file in EnumerateFilesAsync(folderPath, "*.txt", 
                SearchOption.AllDirectories, cancellationToken))
            {
                files.Add(file);
            }
        }
        catch (DirectoryNotFoundException)
        {
            throw new ArgumentException($"æ–‡ä»¶å¤¹ä¸å­˜åœ¨: {folderPath}");
        }
        catch (UnauthorizedAccessException)
        {
            throw new UnauthorizedAccessException($"æ²¡æœ‰è®¿é—®æƒé™: {folderPath}");
        }
        
        return files;
    }
    
    private async IAsyncEnumerable<string> EnumerateFilesAsync(
        string path, 
        string searchPattern, 
        SearchOption searchOption,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        var directories = new Queue<string>();
        directories.Enqueue(path);
        
        while (directories.Count > 0)
        {
            cancellationToken.ThrowIfCancellationRequested();
            
            var currentDir = directories.Dequeue();
            
            try
            {
                // è·å–æ–‡ä»¶
                var files = Directory.GetFiles(currentDir, searchPattern);
                foreach (var file in files)
                {
                    yield return file;
                }
                
                // è·å–å­ç›®å½•
                if (searchOption == SearchOption.AllDirectories)
                {
                    var subDirs = Directory.GetDirectories(currentDir);
                    foreach (var subDir in subDirs)
                    {
                        directories.Enqueue(subDir);
                    }
                }
            }
            catch (UnauthorizedAccessException)
            {
                // è·³è¿‡æ— æƒé™çš„ç›®å½•
                continue;
            }
        }
    }
}
```

### 2. æ–‡ä»¶å†…å®¹è¯»å–ä¼˜åŒ–

```csharp
// ä¼˜åŒ–çš„æ–‡ä»¶è¯»å–
public class FileReader
{
    public async Task<string> ReadFileContentAsync(string filePath, 
        CancellationToken cancellationToken = default)
    {
        try
        {
            // æ£€æŸ¥æ–‡ä»¶å¤§å°
            var fileInfo = new FileInfo(filePath);
            if (fileInfo.Length > 100 * 1024 * 1024) // 100MB
            {
                throw new InvalidOperationException($"æ–‡ä»¶è¿‡å¤§: {filePath}");
            }
            
            // å¼‚æ­¥è¯»å–æ–‡ä»¶
            using var fileStream = File.OpenRead(filePath);
            using var reader = new StreamReader(fileStream);
            
            return await reader.ReadToEndAsync();
        }
        catch (FileNotFoundException)
        {
            throw new FileNotFoundException($"æ–‡ä»¶ä¸å­˜åœ¨: {filePath}");
        }
        catch (IOException ex)
        {
            throw new IOException($"è¯»å–æ–‡ä»¶å¤±è´¥: {filePath}", ex);
        }
    }
    
    // æ‰¹é‡è¯»å–æ–‡ä»¶
    public async Task<Dictionary<string, string>> ReadMultipleFilesAsync(
        IEnumerable<string> filePaths,
        CancellationToken cancellationToken = default)
    {
        var results = new Dictionary<string, string>();
        
        var tasks = filePaths.Select(async filePath =>
        {
            try
            {
                var content = await ReadFileContentAsync(filePath, cancellationToken);
                return new { FilePath = filePath, Content = content, Success = true };
            }
            catch (Exception ex)
            {
                return new { FilePath = filePath, Content = (string?)null, Success = false, Error = ex.Message };
            }
        });
        
        var taskResults = await Task.WhenAll(tasks);
        
        foreach (var result in taskResults)
        {
            if (result.Success)
            {
                results[result.FilePath] = result.Content!;
            }
            else
            {
                // è®°å½•é”™è¯¯ä½†ä¸ä¸­æ–­å¤„ç†
                Console.WriteLine($"è¯»å–æ–‡ä»¶å¤±è´¥ {result.FilePath}: {result.Error}");
            }
        }
        
        return results;
    }
}
```

---

## âš ï¸ é”™è¯¯å¤„ç†æœºåˆ¶

### 1. åˆ†å±‚é”™è¯¯å¤„ç†

```csharp
// åˆ†å±‚é”™è¯¯å¤„ç†ç­–ç•¥
public class ErrorHandler
{
    public async Task<ProcessResult> ProcessWithErrorHandling(string folderPath)
    {
        try
        {
            // 1. å‚æ•°éªŒè¯
            ValidateInput(folderPath);
            
            // 2. æ–‡ä»¶æ‰«æ
            var files = await ScanFiles(folderPath);
            
            // 3. æ‰¹é‡å¤„ç†
            var results = await ProcessFiles(files);
            
            return ProcessResult.Success(results);
        }
        catch (ArgumentException ex)
        {
            return ProcessResult.Error($"å‚æ•°é”™è¯¯: {ex.Message}");
        }
        catch (DirectoryNotFoundException ex)
        {
            return ProcessResult.Error($"æ–‡ä»¶å¤¹ä¸å­˜åœ¨: {ex.Message}");
        }
        catch (UnauthorizedAccessException ex)
        {
            return ProcessResult.Error($"è®¿é—®æƒé™ä¸è¶³: {ex.Message}");
        }
        catch (IOException ex)
        {
            return ProcessResult.Error($"æ–‡ä»¶æ“ä½œå¤±è´¥: {ex.Message}");
        }
        catch (Exception ex)
        {
            return ProcessResult.Error($"æœªçŸ¥é”™è¯¯: {ex.Message}");
        }
    }
    
    private void ValidateInput(string folderPath)
    {
        if (string.IsNullOrWhiteSpace(folderPath))
            throw new ArgumentException("æ–‡ä»¶å¤¹è·¯å¾„ä¸èƒ½ä¸ºç©º");
            
        if (!Directory.Exists(folderPath))
            throw new DirectoryNotFoundException($"æ–‡ä»¶å¤¹ä¸å­˜åœ¨: {folderPath}");
    }
}
```

### 2. æ–‡ä»¶çº§é”™è¯¯å¤„ç†

```csharp
// å•ä¸ªæ–‡ä»¶é”™è¯¯å¤„ç†
public async Task<FileProcessResult> ProcessSingleFileAsync(string filePath)
{
    try
    {
        // æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥
        if (!File.Exists(filePath))
        {
            return FileProcessResult.Error($"æ–‡ä»¶ä¸å­˜åœ¨: {filePath}");
        }
        
        // æ–‡ä»¶å¤§å°æ£€æŸ¥
        var fileInfo = new FileInfo(filePath);
        if (fileInfo.Length == 0)
        {
            return FileProcessResult.Error($"æ–‡ä»¶ä¸ºç©º: {filePath}");
        }
        
        if (fileInfo.Length > 50 * 1024 * 1024) // 50MB
        {
            return FileProcessResult.Error($"æ–‡ä»¶è¿‡å¤§: {filePath}");
        }
        
        // è¯»å–å’Œå¤„ç†æ–‡ä»¶
        var content = await File.ReadAllTextAsync(filePath);
        var tags = TextParser.ParseText(content);
        
        return FileProcessResult.Success(filePath, tags);
    }
    catch (UnauthorizedAccessException)
    {
        return FileProcessResult.Error($"æ²¡æœ‰è¯»å–æƒé™: {filePath}");
    }
    catch (IOException ex)
    {
        return FileProcessResult.Error($"æ–‡ä»¶è¯»å–å¤±è´¥: {filePath}, é”™è¯¯: {ex.Message}");
    }
    catch (Exception ex)
    {
        return FileProcessResult.Error($"å¤„ç†æ–‡ä»¶å¤±è´¥: {filePath}, é”™è¯¯: {ex.Message}");
    }
}
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å†…å­˜ä¼˜åŒ–

```csharp
// å†…å­˜ä¼˜åŒ–çš„æ‰¹é‡å¤„ç†
public class MemoryOptimizedProcessor
{
    private const int MaxMemoryFiles = 100; // æœ€å¤§åŒæ—¶å¤„ç†æ–‡ä»¶æ•°
    
    public async Task<ProcessResult> ProcessLargeFolderAsync(string folderPath)
    {
        var files = Directory.GetFiles(folderPath, "*.txt", SearchOption.AllDirectories);
        
        if (files.Length > MaxMemoryFiles)
        {
            // åˆ†æ‰¹å¤„ç†å¤§æ–‡ä»¶å¤¹
            return await ProcessInBatches(files);
        }
        else
        {
            // ç›´æ¥å¤„ç†å°æ–‡ä»¶å¤¹
            return await ProcessDirectly(files);
        }
    }
    
    private async Task<ProcessResult> ProcessInBatches(string[] files)
    {
        var batchSize = MaxMemoryFiles;
        var allResults = new Dictionary<string, TagInfoViewModel>();
        
        for (int i = 0; i < files.Length; i += batchSize)
        {
            var batch = files.Skip(i).Take(batchSize);
            var batchResults = await ProcessBatch(batch);
            
            // åˆå¹¶æ‰¹æ¬¡ç»“æœ
            MergeBatchResults(allResults, batchResults);
            
            // å¼ºåˆ¶åƒåœ¾å›æ”¶
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }
        
        return ProcessResult.Success(allResults.Values.ToList());
    }
    
    private async Task<Dictionary<string, TagInfoViewModel>> ProcessBatch(
        IEnumerable<string> batchFiles)
    {
        var results = new Dictionary<string, TagInfoViewModel>();
        
        // å¹¶è¡Œå¤„ç†æ‰¹æ¬¡å†…çš„æ–‡ä»¶
        var tasks = batchFiles.Select(async filePath =>
        {
            try
            {
                var content = await File.ReadAllTextAsync(filePath);
                var tags = TextParser.ParseText(content);
                return new { FilePath = filePath, Tags = tags };
            }
            catch (Exception ex)
            {
                return new { FilePath = filePath, Tags = (List<TagInfo>?)null, Error = ex.Message };
            }
        });
        
        var taskResults = await Task.WhenAll(tasks);
        
        foreach (var result in taskResults)
        {
            if (result.Tags != null)
            {
                MergeResults(results, result.Tags, result.FilePath);
            }
        }
        
        return results;
    }
}
```

### 2. å¹¶å‘ä¼˜åŒ–

```csharp
// å¹¶å‘å¤„ç†ä¼˜åŒ–
public class ConcurrentProcessor
{
    private readonly SemaphoreSlim _semaphore;
    
    public ConcurrentProcessor(int maxConcurrency = 4)
    {
        _semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency);
    }
    
    public async Task<List<TagInfoViewModel>> ProcessConcurrentlyAsync(
        IEnumerable<string> filePaths)
    {
        var tasks = filePaths.Select(filePath => ProcessFileWithSemaphore(filePath));
        var results = await Task.WhenAll(tasks);
        
        // åˆå¹¶æ‰€æœ‰ç»“æœ
        var mergedResults = new Dictionary<string, TagInfoViewModel>();
        foreach (var result in results.Where(r => r != null))
        {
            MergeResults(mergedResults, result);
        }
        
        return mergedResults.Values.ToList();
    }
    
    private async Task<TagInfoViewModel?> ProcessFileWithSemaphore(string filePath)
    {
        await _semaphore.WaitAsync();
        try
        {
            return await ProcessSingleFile(filePath);
        }
        finally
        {
            _semaphore.Release();
        }
    }
    
    public void Dispose()
    {
        _semaphore?.Dispose();
    }
}
```

---

## ğŸ§ª æµ‹è¯•ä¸éªŒè¯

### 1. å•å…ƒæµ‹è¯•

```csharp
// æ‰¹é‡å¤„ç†åŠŸèƒ½æµ‹è¯•
[TestClass]
public class BatchProcessingTests
{
    private string _testFolderPath = string.Empty;
    
    [TestInitialize]
    public void Setup()
    {
        _testFolderPath = Path.Combine(Path.GetTempPath(), "TagAnalyzerTest");
        Directory.CreateDirectory(_testFolderPath);
        
        // åˆ›å»ºæµ‹è¯•æ–‡ä»¶
        CreateTestFiles();
    }
    
    [TestCleanup]
    public void Cleanup()
    {
        if (Directory.Exists(_testFolderPath))
        {
            Directory.Delete(_testFolderPath, true);
        }
    }
    
    [TestMethod]
    public async Task ProcessFolderAsync_ShouldMergeResultsCorrectly()
    {
        // Arrange
        var viewModel = new MainWindowViewModel();
        
        // Act
        await viewModel.ProcessFolderAsync(_testFolderPath);
        
        // Assert
        Assert.IsTrue(viewModel.TagInfos.Count > 0);
        
        var tagInfo = viewModel.TagInfos.FirstOrDefault(t => t.Tag == "æŠ½æ³£");
        Assert.IsNotNull(tagInfo);
        Assert.AreEqual(3, tagInfo.Count); // åº”è¯¥åˆå¹¶3ä¸ªæ–‡ä»¶ä¸­çš„æŠ½æ³£æ ‡ç­¾
        Assert.IsTrue(tagInfo.SourceFiles.Contains("file1.txt"));
        Assert.IsTrue(tagInfo.SourceFiles.Contains("file2.txt"));
        Assert.IsTrue(tagInfo.SourceFiles.Contains("file3.txt"));
    }
    
    [TestMethod]
    public async Task ProcessFolderAsync_ShouldHandleEmptyFolder()
    {
        // Arrange
        var emptyFolder = Path.Combine(_testFolderPath, "empty");
        Directory.CreateDirectory(emptyFolder);
        var viewModel = new MainWindowViewModel();
        
        // Act
        await viewModel.ProcessFolderAsync(emptyFolder);
        
        // Assert
        Assert.AreEqual("æ–‡ä»¶å¤¹ä¸­æ²¡æœ‰æ‰¾åˆ°txtæ–‡ä»¶", viewModel.StatusMessage);
        Assert.AreEqual(0, viewModel.TagInfos.Count);
    }
    
    [TestMethod]
    public async Task ProcessFolderAsync_ShouldHandleFileErrors()
    {
        // Arrange
        var errorFile = Path.Combine(_testFolderPath, "error.txt");
        File.WriteAllText(errorFile, "invalid content");
        var viewModel = new MainWindowViewModel();
        
        // Act
        await viewModel.ProcessFolderAsync(_testFolderPath);
        
        // Assert
        // åº”è¯¥å¤„ç†æˆåŠŸï¼Œä½†è·³è¿‡é”™è¯¯æ–‡ä»¶
        Assert.IsTrue(viewModel.TagInfos.Count > 0);
    }
    
    private void CreateTestFiles()
    {
        // åˆ›å»ºæµ‹è¯•æ–‡ä»¶
        File.WriteAllText(Path.Combine(_testFolderPath, "file1.txt"), 
            "M35_230001ã€æŠ½æ³£ã€‘ç¬¬ä¸€ä¸ªæ–‡ä»¶\nM35_230002ã€å¹æ°”ã€‘");
        
        File.WriteAllText(Path.Combine(_testFolderPath, "file2.txt"), 
            "M35_230003ã€æŠ½æ³£ã€‘ç¬¬äºŒä¸ªæ–‡ä»¶\nM35_230004ã€æ–°æ ‡ç­¾ã€‘");
        
        File.WriteAllText(Path.Combine(_testFolderPath, "file3.txt"), 
            "M35_230005ã€æŠ½æ³£ã€‘ç¬¬ä¸‰ä¸ªæ–‡ä»¶\nM35_230006ã€ç‹¬ç‰¹æ ‡ç­¾ã€‘");
    }
}
```

### 2. æ€§èƒ½æµ‹è¯•

```csharp
// æ€§èƒ½æµ‹è¯•
[TestClass]
public class PerformanceTests
{
    [TestMethod]
    public async Task ProcessLargeFolder_ShouldCompleteWithinTimeLimit()
    {
        // Arrange
        var largeFolder = CreateLargeTestFolder(1000); // 1000ä¸ªæ–‡ä»¶
        var viewModel = new MainWindowViewModel();
        var stopwatch = Stopwatch.StartNew();
        
        // Act
        await viewModel.ProcessFolderAsync(largeFolder);
        stopwatch.Stop();
        
        // Assert
        Assert.IsTrue(stopwatch.ElapsedMilliseconds < 30000); // 30ç§’å†…å®Œæˆ
        Assert.IsTrue(viewModel.TagInfos.Count > 0);
        
        // Cleanup
        Directory.Delete(largeFolder, true);
    }
    
    [TestMethod]
    public async Task MemoryUsage_ShouldRemainStable()
    {
        // Arrange
        var folder = CreateLargeTestFolder(500);
        var viewModel = new MainWindowViewModel();
        
        // Act
        var initialMemory = GC.GetTotalMemory(true);
        await viewModel.ProcessFolderAsync(folder);
        var finalMemory = GC.GetTotalMemory(true);
        
        // Assert
        var memoryIncrease = finalMemory - initialMemory;
        Assert.IsTrue(memoryIncrease < 100 * 1024 * 1024); // å†…å­˜å¢é•¿å°äº100MB
        
        // Cleanup
        Directory.Delete(folder, true);
    }
    
    private string CreateLargeTestFolder(int fileCount)
    {
        var folder = Path.Combine(Path.GetTempPath(), "LargeTestFolder");
        Directory.CreateDirectory(folder);
        
        for (int i = 0; i < fileCount; i++)
        {
            var content = $"M35_{i:D6}ã€æ ‡ç­¾{i % 10}ã€‘æµ‹è¯•å†…å®¹\nM35_{i + 1:D6}ã€å¦ä¸€ä¸ªæ ‡ç­¾ã€‘";
            File.WriteAllText(Path.Combine(folder, $"file{i}.txt"), content);
        }
        
        return folder;
    }
}
```

---

## ğŸ“ æ€»ç»“

### æŠ€æœ¯äº®ç‚¹

1. **C# 14 ç°ä»£è¯­æ³•**ï¼šé›†åˆè¡¨è¾¾å¼ã€æ¨¡å¼åŒ¹é…ã€å¿…éœ€æˆå‘˜
2. **å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼**ï¼šasync/awaitã€IAsyncEnumerableã€ConfigureAwait
3. **MVVM æ¶æ„**ï¼šæ•°æ®ç»‘å®šã€å‘½ä»¤æ¨¡å¼ã€å±æ€§é€šçŸ¥
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šå†…å­˜ç®¡ç†ã€å¹¶å‘å¤„ç†ã€æ‰¹é‡æ“ä½œ
5. **é”™è¯¯å¤„ç†**ï¼šåˆ†å±‚å¼‚å¸¸å¤„ç†ã€ä¼˜é›…é™çº§
6. **ç”¨æˆ·ä½“éªŒ**ï¼šå®æ—¶è¿›åº¦åé¦ˆã€çŠ¶æ€æ˜¾ç¤º

### æœ€ä½³å®è·µ

1. **æ•°æ®åˆå¹¶**ï¼šä½¿ç”¨ Dictionary é«˜æ•ˆåˆå¹¶æ ‡ç­¾ç»Ÿè®¡
2. **å¼‚æ­¥å¤„ç†**ï¼šé¿å…é˜»å¡UIçº¿ç¨‹
3. **å†…å­˜ç®¡ç†**ï¼šåŠæ—¶é‡Šæ”¾èµ„æºï¼Œé¿å…å†…å­˜æ³„æ¼
4. **é”™è¯¯å¤„ç†**ï¼šåˆ†å±‚å¤„ç†ä¸åŒç±»å‹çš„å¼‚å¸¸
5. **è¿›åº¦åé¦ˆ**ï¼šå®æ—¶æ›´æ–°å¤„ç†çŠ¶æ€å’Œè¿›åº¦
6. **æµ‹è¯•è¦†ç›–**ï¼šå•å…ƒæµ‹è¯•å’Œæ€§èƒ½æµ‹è¯•

è¿™å¥—æ‰¹é‡å¤„ç†åŠŸèƒ½å±•ç°äº†ç°ä»£ .NET 10 + C# 14 å¼€å‘çš„æœ€ä½³å®è·µï¼Œä¸ºå¤„ç†å¤§é‡æ–‡ä»¶æä¾›äº†é«˜æ•ˆã€ç¨³å®šçš„è§£å†³æ–¹æ¡ˆï¼
