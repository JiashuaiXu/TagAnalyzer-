# C# 14 è¯­æ³•ç³–åœ¨é¡¹ç›®ä¸­çš„åº”ç”¨ç¤ºä¾‹

## ğŸ“‹ ç›®å½•

1. [é›†åˆè¡¨è¾¾å¼åº”ç”¨](#é›†åˆè¡¨è¾¾å¼åº”ç”¨)
2. [æ¨¡å¼åŒ¹é…å¢å¼º](#æ¨¡å¼åŒ¹é…å¢å¼º)
3. [å¿…éœ€æˆå‘˜ä½¿ç”¨](#å¿…éœ€æˆå‘˜ä½¿ç”¨)
4. [æ–‡ä»¶æœ¬åœ°ç±»å‹](#æ–‡ä»¶æœ¬åœ°ç±»å‹)
5. [å¼‚æ­¥æµå¢å¼º](#å¼‚æ­¥æµå¢å¼º)
6. [æ€§èƒ½ä¼˜åŒ–è¯­æ³•](#æ€§èƒ½ä¼˜åŒ–è¯­æ³•)
7. [å®é™…é¡¹ç›®é›†æˆ](#å®é™…é¡¹ç›®é›†æˆ)

---

## ğŸ¯ é›†åˆè¡¨è¾¾å¼åº”ç”¨

### 1. åœ¨æ•°æ®æ¨¡å‹ä¸­ä½¿ç”¨

```csharp
// Models/TagInfo.cs - ä½¿ç”¨ C# 14 é›†åˆè¡¨è¾¾å¼
namespace TagAnalyzer.Models;

public class TagInfo
{
    public required string Tag { get; set; }
    public required int Count { get; set; }
    
    // C# 14 é›†åˆè¡¨è¾¾å¼åˆå§‹åŒ–
    public List<string> SourceIds { get; set; } = [];
    
    // æ„é€ å‡½æ•°
    public TagInfo(string tag, int count)
    {
        Tag = tag;
        Count = count;
    }
    
    // è§£æ„æ–¹æ³•
    public void Deconstruct(out string tag, out int count, out List<string> sourceIds)
    {
        tag = Tag;
        count = Count;
        sourceIds = SourceIds;
    }
}
```

### 2. åœ¨æœåŠ¡ç±»ä¸­ä½¿ç”¨

```csharp
// Services/FileService.cs - ä½¿ç”¨é›†åˆè¡¨è¾¾å¼
namespace TagAnalyzer.Services;

public class FileService
{
    // æ”¯æŒçš„æ‰©å±•å
    private readonly string[] _supportedExtensions = ["txt", "csv", "json"];
    
    // MIME ç±»å‹æ˜ å°„
    private readonly Dictionary<string, string> _mimeTypes = new()
    {
        ["txt"] = "text/plain",
        ["csv"] = "text/csv",
        ["json"] = "application/json"
    };
    
    // è·å–æ”¯æŒçš„æ–‡ä»¶ç±»å‹
    public IEnumerable<string> GetSupportedFileTypes()
    {
        return ["æ–‡æœ¬æ–‡ä»¶", "CSVæ–‡ä»¶", "JSONæ–‡ä»¶"];
    }
    
    // éªŒè¯æ–‡ä»¶æ‰©å±•å
    public bool IsSupportedExtension(string extension)
    {
        return _supportedExtensions.Contains(extension.ToLower());
    }
}
```

---

## ğŸ” æ¨¡å¼åŒ¹é…å¢å¼º

### 1. åœ¨æ–‡æœ¬è§£æå™¨ä¸­ä½¿ç”¨

```csharp
// Models/TextParser.cs - ä½¿ç”¨ C# 14 æ¨¡å¼åŒ¹é…
namespace TagAnalyzer.Models;

public class TextParser
{
    public ParseResult ParseText(string text)
    {
        var lines = text.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        
        return lines switch
        {
            [] => new ParseResult { Status = "ç©ºæ–‡ä»¶", TagInfos = [] },
            [var singleLine] when singleLine.StartsWith("M35_") => 
                ProcessSingleLine(singleLine),
            [var first, .. var rest] when first.StartsWith("M35_") => 
                ProcessMultipleLines([first, .. rest]),
            _ => new ParseResult { Status = "æ ¼å¼ä¸æ”¯æŒ", TagInfos = [] }
        };
    }
    
    private ParseResult ProcessSingleLine(string line)
    {
        var tags = ExtractTags(line);
        return new ParseResult 
        { 
            Status = "å•è¡Œå¤„ç†å®Œæˆ", 
            TagInfos = tags.Select(t => new TagInfo(t, 1)).ToList() 
        };
    }
    
    private ParseResult ProcessMultipleLines(string[] lines)
    {
        var tagDictionary = new Dictionary<string, TagInfo>();
        
        foreach (var line in lines)
        {
            var tags = ExtractTags(line);
            foreach (var tag in tags)
            {
                if (!tagDictionary.ContainsKey(tag))
                {
                    tagDictionary[tag] = new TagInfo(tag, 0);
                }
                tagDictionary[tag].Count++;
            }
        }
        
        return new ParseResult 
        { 
            Status = "å¤šè¡Œå¤„ç†å®Œæˆ", 
            TagInfos = tagDictionary.Values.ToList() 
        };
    }
    
    private List<string> ExtractTags(string line)
    {
        // æå–æ ‡ç­¾çš„é€»è¾‘
        return [];
    }
}
```

### 2. åœ¨ ViewModel ä¸­ä½¿ç”¨

```csharp
// ViewModels/MainWindowViewModel.cs - ä½¿ç”¨æ¨¡å¼åŒ¹é…
namespace TagAnalyzer.ViewModels;

public class MainWindowViewModel : BaseViewModel
{
    public void HandleCommand(object? parameter)
    {
        switch (parameter)
        {
            case string filePath when !string.IsNullOrEmpty(filePath):
                ProcessFileAsync(filePath);
                break;
            case TagInfo tagInfo:
                SelectTag(tagInfo);
                break;
            case { } obj when obj.GetType().Name.Contains("Export"):
                ExportData();
                break;
            case null:
                StatusMessage = "å‚æ•°ä¸ºç©º";
                break;
        }
    }
    
    // ä½¿ç”¨æ¨¡å¼åŒ¹é…è¿›è¡Œæ•°æ®éªŒè¯
    public bool ValidateInput(object? input)
    {
        return input switch
        {
            string s when s.Length > 0 => true,
            int i when i > 0 => true,
            TagInfo t when !string.IsNullOrEmpty(t.Tag) => true,
            _ => false
        };
    }
}
```

---

## ğŸ”§ å¿…éœ€æˆå‘˜ä½¿ç”¨

### 1. é…ç½®ç±»ä½¿ç”¨å¿…éœ€æˆå‘˜

```csharp
// Models/AppConfig.cs - ä½¿ç”¨å¿…éœ€æˆå‘˜
namespace TagAnalyzer.Models;

public class AppConfig
{
    // å¿…éœ€çš„æ ¸å¿ƒé…ç½®
    public required string AppName { get; set; }
    public required string Version { get; set; }
    public required string Author { get; set; }
    
    // å¯é€‰é…ç½®
    public int MaxFileSize { get; set; } = 10 * 1024 * 1024; // 10MB
    public bool EnableLogging { get; set; } = true;
    public List<string> SupportedFormats { get; set; } = ["txt", "csv"];
    
    // é™æ€å·¥å‚æ–¹æ³•
    public static AppConfig CreateDefault()
    {
        return new AppConfig
        {
            AppName = "Tag Analyzer",
            Version = "1.0.0",
            Author = "jiashuai_xu@qq.com"
        };
    }
}
```

### 2. æ•°æ®æ¨¡å‹ä½¿ç”¨å¿…éœ€æˆå‘˜

```csharp
// Models/ParseResult.cs - ä½¿ç”¨å¿…éœ€æˆå‘˜
namespace TagAnalyzer.Models;

public class ParseResult
{
    public required List<TagInfo> TagInfos { get; set; }
    public required int ProcessedLines { get; set; }
    public required TimeSpan ProcessingTime { get; set; }
    
    // å¯é€‰å±æ€§
    public List<string> Errors { get; set; } = [];
    public string Status { get; set; } = "å®Œæˆ";
    
    // è®¡ç®—å±æ€§
    public bool HasErrors => Errors.Count > 0;
    public int TotalTags => TagInfos.Count;
    
    // å·¥å‚æ–¹æ³•
    public static ParseResult CreateEmpty()
    {
        return new ParseResult
        {
            TagInfos = [],
            ProcessedLines = 0,
            ProcessingTime = TimeSpan.Zero
        };
    }
}
```

---

## ğŸ“ æ–‡ä»¶æœ¬åœ°ç±»å‹

### 1. å†…éƒ¨è¾…åŠ©ç±»

```csharp
// Models/TextParser.cs
namespace TagAnalyzer.Models;

// æ–‡ä»¶æœ¬åœ°ç±»å‹ - åªåœ¨å½“å‰æ–‡ä»¶ä¸­å¯è§
file class TagExtractor
{
    private static readonly Regex TagPattern = new(@"ã€([^ã€‘]+)ã€‘", RegexOptions.Compiled);
    
    public static List<string> ExtractTags(string text)
    {
        var matches = TagPattern.Matches(text);
        return matches.Cast<Match>()
                     .Select(m => m.Groups[1].Value)
                     .ToList();
    }
}

public class TextParser
{
    public List<TagInfo> ParseText(string text)
    {
        var lines = text.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        var result = [];
        
        foreach (var line in lines)
        {
            if (line.StartsWith("M35_"))
            {
                var tags = TagExtractor.ExtractTags(line);
                foreach (var tag in tags)
                {
                    result.Add(new TagInfo(tag, 1));
                }
            }
        }
        
        return result;
    }
}
```

### 2. å†…éƒ¨éªŒè¯ç±»

```csharp
// Services/FileService.cs
namespace TagAnalyzer.Services;

// æ–‡ä»¶æœ¬åœ°ç±»å‹ - éªŒè¯é€»è¾‘
file class FileValidator
{
    private static readonly string[] AllowedExtensions = ["txt", "csv", "json"];
    private const long MaxFileSize = 100 * 1024 * 1024; // 100MB
    
    public static bool IsValidFile(string filePath)
    {
        if (!File.Exists(filePath))
            return false;
            
        var extension = Path.GetExtension(filePath).TrimStart('.');
        if (!AllowedExtensions.Contains(extension))
            return false;
            
        var fileInfo = new FileInfo(filePath);
        if (fileInfo.Length > MaxFileSize)
            return false;
            
        return true;
    }
}

public class FileService
{
    public async Task<string> ReadFileAsync(string filePath)
    {
        if (!FileValidator.IsValidFile(filePath))
            throw new ArgumentException("æ— æ•ˆçš„æ–‡ä»¶");
            
        return await File.ReadAllTextAsync(filePath);
    }
}
```

---

## âš¡ å¼‚æ­¥æµå¢å¼º

### 1. æ–‡ä»¶å¤„ç†å¼‚æ­¥æµ

```csharp
// Services/BatchFileProcessor.cs - ä½¿ç”¨å¼‚æ­¥æµ
namespace TagAnalyzer.Services;

public class BatchFileProcessor
{
    public async IAsyncEnumerable<ParseResult> ProcessFilesAsync(
        IEnumerable<string> filePaths,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        foreach (var filePath in filePaths)
        {
            cancellationToken.ThrowIfCancellationRequested();
            
            try
            {
                var content = await File.ReadAllTextAsync(filePath, cancellationToken);
                var result = await Task.Run(() => TextParser.ParseText(content), cancellationToken);
                
                yield return result;
            }
            catch (Exception ex)
            {
                yield return new ParseResult
                {
                    TagInfos = [],
                    ProcessedLines = 0,
                    ProcessingTime = TimeSpan.Zero,
                    Errors = [$"å¤„ç†æ–‡ä»¶ {filePath} å¤±è´¥: {ex.Message}"]
                };
            }
        }
    }
    
    // ä½¿ç”¨ ConfigureAwait(false) ä¼˜åŒ–
    public async Task<ParseResult> ProcessFileAsync(string filePath, CancellationToken cancellationToken = default)
    {
        await using var file = File.OpenRead(filePath);
        using var reader = new StreamReader(file);
        
        var content = await reader.ReadToEndAsync(cancellationToken).ConfigureAwait(false);
        
        return await Task.Run(() => TextParser.ParseText(content), cancellationToken).ConfigureAwait(false);
    }
}
```

### 2. ViewModel ä¸­çš„å¼‚æ­¥æµä½¿ç”¨

```csharp
// ViewModels/MainWindowViewModel.cs - å¼‚æ­¥æµé›†æˆ
namespace TagAnalyzer.ViewModels;

public class MainWindowViewModel : BaseViewModel
{
    private readonly BatchFileProcessor _batchProcessor;
    
    public MainWindowViewModel()
    {
        _batchProcessor = new BatchFileProcessor();
    }
    
    public async Task ProcessMultipleFilesAsync(IEnumerable<string> filePaths)
    {
        IsProcessing = true;
        StatusMessage = "å¼€å§‹æ‰¹é‡å¤„ç†...";
        
        try
        {
            var results = [];
            await foreach (var result in _batchProcessor.ProcessFilesAsync(filePaths))
            {
                results.Add(result);
                StatusMessage = $"å·²å¤„ç† {results.Count} ä¸ªæ–‡ä»¶";
                
                // æ›´æ–° UI
                OnPropertyChanged(nameof(StatusMessage));
            }
            
            StatusMessage = $"æ‰¹é‡å¤„ç†å®Œæˆï¼Œå…±å¤„ç† {results.Count} ä¸ªæ–‡ä»¶";
        }
        catch (OperationCanceledException)
        {
            StatusMessage = "å¤„ç†å·²å–æ¶ˆ";
        }
        catch (Exception ex)
        {
            StatusMessage = $"æ‰¹é‡å¤„ç†å¤±è´¥: {ex.Message}";
        }
        finally
        {
            IsProcessing = false;
        }
    }
}
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–è¯­æ³•

### 1. Span<T> å’Œ Memory<T> ä½¿ç”¨

```csharp
// Utils/HighPerformanceParser.cs - é«˜æ€§èƒ½è§£æ
namespace TagAnalyzer.Utils;

public class HighPerformanceParser
{
    public ReadOnlySpan<char> ExtractTag(ReadOnlySpan<char> line)
    {
        var startIndex = line.IndexOf("ã€");
        if (startIndex == -1) return ReadOnlySpan<char>.Empty;
        
        var endIndex = line.IndexOf("ã€‘", startIndex);
        if (endIndex == -1) return ReadOnlySpan<char>.Empty;
        
        return line.Slice(startIndex + 1, endIndex - startIndex - 1);
    }
    
    // ä½¿ç”¨ Memory<T> è¿›è¡Œå¼‚æ­¥å¤„ç†
    public async Task<Memory<char>> ProcessTextAsync(Memory<char> text)
    {
        await Task.Delay(100); // æ¨¡æ‹Ÿå¼‚æ­¥å¤„ç†
        return text;
    }
    
    // æ‰¹é‡å¤„ç†ä½¿ç”¨ Span<T>
    public List<string> ExtractAllTags(ReadOnlySpan<char> text)
    {
        var tags = [];
        var remaining = text;
        
        while (remaining.Length > 0)
        {
            var tag = ExtractTag(remaining);
            if (tag.Length > 0)
            {
                tags.Add(tag.ToString());
                remaining = remaining.Slice(remaining.IndexOf(tag) + tag.Length);
            }
            else
            {
                break;
            }
        }
        
        return tags;
    }
}
```

### 2. è®°å½•ç±»å‹æ€§èƒ½ä¼˜åŒ–

```csharp
// Models/PerformanceOptimizedResult.cs - è®°å½•ç±»å‹ä¼˜åŒ–
namespace TagAnalyzer.Models;

// ä½¿ç”¨è®°å½•ç±»å‹æé«˜æ€§èƒ½
public record ParseResult(
    List<TagInfo> TagInfos,
    int ProcessedLines,
    TimeSpan ProcessingTime,
    List<string> Errors = []
)
{
    // è®¡ç®—å±æ€§
    public bool HasErrors => Errors.Count > 0;
    public int TotalTags => TagInfos.Count;
    
    // æ–¹æ³•
    public string GetSummary() => 
        $"å¤„ç†å®Œæˆ: {TotalTags} ä¸ªæ ‡ç­¾, {ProcessedLines} è¡Œ, è€—æ—¶ {ProcessingTime:mm\\:ss}";
    
    // é™æ€å·¥å‚æ–¹æ³•
    public static ParseResult CreateEmpty() => new([], 0, TimeSpan.Zero);
    
    public static ParseResult CreateSuccess(List<TagInfo> tagInfos, int lines, TimeSpan time) =>
        new(tagInfos, lines, time);
}

// ç»“æ„ä½“è®°å½•ç”¨äºé«˜æ€§èƒ½åœºæ™¯
public readonly record struct TagInfoStruct(string Tag, int Count)
{
    public static TagInfoStruct FromTagInfo(TagInfo tagInfo) => 
        new(tagInfo.Tag, tagInfo.Count);
}
```

---

## ğŸ”— å®é™…é¡¹ç›®é›†æˆ

### 1. å®Œæ•´çš„ ViewModel ç¤ºä¾‹

```csharp
// ViewModels/MainWindowViewModel.cs - å®Œæ•´é›†æˆç¤ºä¾‹
namespace TagAnalyzer.ViewModels;

public class MainWindowViewModel : BaseViewModel
{
    private readonly FileService _fileService;
    private readonly HighPerformanceParser _parser;
    
    // C# 14 é›†åˆè¡¨è¾¾å¼åˆå§‹åŒ–
    private readonly List<string> _supportedFormats = ["txt", "csv", "json"];
    
    // å¿…éœ€æˆå‘˜é…ç½®
    private readonly AppConfig _config = AppConfig.CreateDefault();
    
    public MainWindowViewModel()
    {
        _fileService = new FileService();
        _parser = new HighPerformanceParser();
        
        // åˆå§‹åŒ–é›†åˆ
        TagInfos = [];
    }
    
    public ObservableCollection<TagInfoViewModel> TagInfos { get; set; } = [];
    
    public async Task ProcessFileAsync(string filePath)
    {
        if (!_supportedFormats.Contains(Path.GetExtension(filePath).TrimStart('.')))
        {
            StatusMessage = "ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼";
            return;
        }
        
        IsProcessing = true;
        StatusMessage = "æ­£åœ¨å¤„ç†æ–‡ä»¶...";
        
        try
        {
            var content = await _fileService.ReadFileAsync(filePath);
            var result = await ProcessContentAsync(content);
            
            // ä½¿ç”¨æ¨¡å¼åŒ¹é…å¤„ç†ç»“æœ
            ProcessResult(result);
        }
        catch (Exception ex)
        {
            StatusMessage = $"å¤„ç†å¤±è´¥: {ex.Message}";
        }
        finally
        {
            IsProcessing = false;
        }
    }
    
    private async Task<ParseResult> ProcessContentAsync(string content)
    {
        return await Task.Run(() =>
        {
            var startTime = DateTime.Now;
            var lines = content.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            var tagInfos = [];
            
            foreach (var line in lines)
            {
                if (line.StartsWith("M35_"))
                {
                    var tags = _parser.ExtractAllTags(line.AsSpan());
                    foreach (var tag in tags)
                    {
                        tagInfos.Add(new TagInfo(tag, 1));
                    }
                }
            }
            
            return ParseResult.CreateSuccess(tagInfos, lines.Length, DateTime.Now - startTime);
        });
    }
    
    private void ProcessResult(ParseResult result)
    {
        // ä½¿ç”¨æ¨¡å¼åŒ¹é…å¤„ç†ç»“æœ
        var message = result switch
        {
            { HasErrors: true } => $"å¤„ç†å®Œæˆä½†æœ‰é”™è¯¯: {result.Errors.Count} ä¸ª",
            { TotalTags: 0 } => "æœªæ‰¾åˆ°ä»»ä½•æ ‡ç­¾",
            { TotalTags: > 0 } => $"æ‰¾åˆ° {result.TotalTags} ä¸ªæ ‡ç­¾",
            _ => "å¤„ç†å®Œæˆ"
        };
        
        StatusMessage = message;
        
        // æ›´æ–° UI
        TagInfos.Clear();
        foreach (var tagInfo in result.TagInfos)
        {
            TagInfos.Add(new TagInfoViewModel(tagInfo));
        }
    }
}
```

### 2. é¡¹ç›®é…ç½®é›†æˆ

```xml
<!-- TagAnalyzer.csproj - å®Œæ•´é…ç½® -->
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <LangVersion>14</LangVersion>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <BuiltInComInteropSupport>true</BuiltInComInteropSupport>
    <ApplicationManifest>app.manifest</ApplicationManifest>
    <AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>
    
    <!-- C# 14 é¢„è§ˆç‰¹æ€§ -->
    <EnablePreviewFeatures>true</EnablePreviewFeatures>
    <AnalysisLevel>latest</AnalysisLevel>
    
    <!-- æ€§èƒ½ä¼˜åŒ– -->
    <PublishReadyToRun>true</PublishReadyToRun>
    <PublishTrimmed>true</PublishTrimmed>
    <TrimMode>link</TrimMode>
    
    <!-- é¡¹ç›®ä¿¡æ¯ -->
    <AssemblyTitle>Tag Analyzer (.NET 10 + C# 14)</AssemblyTitle>
    <AssemblyDescription>ä½¿ç”¨æœ€æ–° C# 14 è¯­æ³•ç‰¹æ€§çš„æ ‡ç­¾åˆ†æå·¥å…·</AssemblyDescription>
    <AssemblyCompany>jiashuai_xu@qq.com</AssemblyCompany>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </PropertyGroup>

  <ItemGroup>
    <!-- Avalonia UI -->
    <PackageReference Include="Avalonia" Version="11.1.0" />
    <PackageReference Include="Avalonia.Desktop" Version="11.1.0" />
    <PackageReference Include="Avalonia.Themes.Fluent" Version="11.1.0" />
    <PackageReference Include="Avalonia.Fonts.Inter" Version="11.1.0" />
    <PackageReference Include="Avalonia.ReactiveUI" Version="11.1.0" />
    
    <!-- ç¬¬ä¸‰æ–¹åº“ -->
    <PackageReference Include="CsvHelper" Version="33.0.1" />
    
    <!-- C# 14 å¢å¼ºåº“ -->
    <PackageReference Include="System.Memory" Version="4.5.5" />
    <PackageReference Include="System.Threading.Tasks.Extensions" Version="4.5.4" />
  </ItemGroup>
</Project>
```

---

## ğŸ¯ æ€»ç»“

C# 14 è¯­æ³•ç³–åœ¨é¡¹ç›®ä¸­çš„åº”ç”¨åŒ…æ‹¬ï¼š

1. **é›†åˆè¡¨è¾¾å¼**ï¼šç®€åŒ–é›†åˆåˆå§‹åŒ–ï¼Œæé«˜ä»£ç å¯è¯»æ€§
2. **æ¨¡å¼åŒ¹é…**ï¼šå¢å¼ºæ¡ä»¶åˆ¤æ–­å’Œæ•°æ®éªŒè¯é€»è¾‘
3. **å¿…éœ€æˆå‘˜**ï¼šç¡®ä¿å…³é”®æ•°æ®å®Œæ•´æ€§
4. **æ–‡ä»¶æœ¬åœ°ç±»å‹**ï¼šé¿å…å‘½åå†²çªï¼Œæé«˜ä»£ç ç»„ç»‡æ€§
5. **å¼‚æ­¥æµ**ï¼šä¼˜åŒ–å¤§æ•°æ®å¤„ç†æ€§èƒ½
6. **æ€§èƒ½ä¼˜åŒ–**ï¼šSpan<T>ã€Memory<T>ã€è®°å½•ç±»å‹ç­‰é«˜æ€§èƒ½ç‰¹æ€§

è¿™äº›æ–°ç‰¹æ€§è®©ä»£ç æ›´åŠ ç®€æ´ã€å®‰å…¨ã€é«˜æ•ˆï¼Œç‰¹åˆ«é€‚åˆç°ä»£æ¡Œé¢åº”ç”¨å¼€å‘ï¼
