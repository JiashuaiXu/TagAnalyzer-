# å¸¸è§é—®é¢˜ä¸è¸©å‘æŒ‡å— (.NET 10 + C# 14)

## ğŸ“‹ ç›®å½•

1. [ç¼–è¯‘é”™è¯¯è§£å†³æ–¹æ¡ˆ](#ç¼–è¯‘é”™è¯¯è§£å†³æ–¹æ¡ˆ)
2. [è¿è¡Œæ—¶é”™è¯¯å¤„ç†](#è¿è¡Œæ—¶é”™è¯¯å¤„ç†)
3. [æ•°æ®ç»‘å®šé—®é¢˜](#æ•°æ®ç»‘å®šé—®é¢˜)
4. [UI å¸ƒå±€é—®é¢˜](#ui-å¸ƒå±€é—®é¢˜)
5. [æ€§èƒ½é—®é¢˜ä¼˜åŒ–](#æ€§èƒ½é—®é¢˜ä¼˜åŒ–)
6. [å‘å¸ƒéƒ¨ç½²é—®é¢˜](#å‘å¸ƒéƒ¨ç½²é—®é¢˜)
7. [è°ƒè¯•æŠ€å·§](#è°ƒè¯•æŠ€å·§)
8. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
9. [.NET 10 + C# 14 ç‰¹å®šé—®é¢˜](#net-10--c-14-ç‰¹å®šé—®é¢˜)
10. [æ‰¹é‡å¤„ç†åŠŸèƒ½ç›¸å…³é—®é¢˜](#æ‰¹é‡å¤„ç†åŠŸèƒ½ç›¸å…³é—®é¢˜)

---

## âš ï¸ ç¼–è¯‘é”™è¯¯è§£å†³æ–¹æ¡ˆ

### 1. XAML ç¼–è¯‘é”™è¯¯

#### é—®é¢˜ï¼šæ§ä»¶æ— æ³•è§£æ
```
error AXN0002: Unable to resolve type DataGrid from namespace https://github.com/avaloniaui
```

**åŸå› åˆ†æ**ï¼š
- ç¼ºå°‘æ­£ç¡®çš„å‘½åç©ºé—´å¼•ç”¨
- æ§ä»¶åç§°æ‹¼å†™é”™è¯¯
- ç‰ˆæœ¬ä¸å…¼å®¹

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- é”™è¯¯çš„æ–¹å¼ -->
<DataGrid ItemsSource="{Binding Items}"/>

<!-- æ­£ç¡®çš„æ–¹å¼ -->
<Window xmlns:avalonia="using:Avalonia.Controls">
    <avalonia:DataGrid ItemsSource="{Binding Items}"/>
</Window>

<!-- æˆ–è€…ä½¿ç”¨å®Œæ•´å‘½åç©ºé—´ -->
<DataGrid xmlns="https://github.com/avaloniaui" ItemsSource="{Binding Items}"/>
```

#### é—®é¢˜ï¼šè½¬æ¢å™¨æ— æ³•æ‰¾åˆ°
```
error AVLN:0004: Unable to resolve NotEqualTo as static field, property, constant or enum value
```

**åŸå› åˆ†æ**ï¼š
- è½¬æ¢å™¨æœªæ­£ç¡®æ³¨å†Œ
- å‘½åç©ºé—´å¼•ç”¨é”™è¯¯
- è½¬æ¢å™¨ç±»ä¸å­˜åœ¨

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- é”™è¯¯çš„æ–¹å¼ -->
<Button IsEnabled="{Binding Count, Converter={x:Static BoolConverters.NotEqualTo}, ConverterParameter=0}"/>

<!-- æ­£ç¡®çš„æ–¹å¼ - ç®€åŒ–ç»‘å®š -->
<Button IsEnabled="{Binding HasData}"/>

<!-- æˆ–è€…è‡ªå®šä¹‰è½¬æ¢å™¨ -->
<Window.Resources>
    <local:CountToBoolConverter x:Key="CountToBoolConverter"/>
</Window.Resources>
<Button IsEnabled="{Binding Count, Converter={StaticResource CountToBoolConverter}}"/>
```

#### é—®é¢˜ï¼šInitializeComponent ä¸å­˜åœ¨
```
error CS0103: The name 'InitializeComponent' does not exist in the current context
```

**åŸå› åˆ†æ**ï¼š
- XAML æ–‡ä»¶ä¸å­˜åœ¨æˆ–æŸå
- å‘½åç©ºé—´ä¸åŒ¹é…
- ç¼–è¯‘é¡ºåºé—®é¢˜

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ£€æŸ¥æ–‡ä»¶ç»“æ„
// MainWindow.axaml å¿…é¡»å­˜åœ¨
// MainWindow.axaml.cs ä¸­çš„å‘½åç©ºé—´å¿…é¡»åŒ¹é…

// ç¡®ä¿å‘½åç©ºé—´ä¸€è‡´
namespace TagAnalyzer;  // åœ¨ .axaml.cs ä¸­

// åœ¨ .axaml ä¸­
x:Class="TagAnalyzer.MainWindow"
```

### 2. C# ç¼–è¯‘é”™è¯¯

#### é—®é¢˜ï¼šç¼ºå°‘ using è¯­å¥
```
error CS0246: The type or namespace name 'List<>' could not be found
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ·»åŠ å¿…è¦çš„ using è¯­å¥
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
```

#### é—®é¢˜ï¼šSTAThread å±æ€§æ‰¾ä¸åˆ°
```
error CS0246: The type or namespace name 'STAThreadAttribute' could not be found
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ·»åŠ  System å‘½åç©ºé—´
using System;
using Avalonia;

[STAThread]
public static void Main(string[] args) => BuildAvaloniaApp()
    .StartWithClassicDesktopLifetime(args);
```

#### é—®é¢˜ï¼šStringSplitOptions æ‰¾ä¸åˆ°
```
error CS0103: The name 'StringSplitOptions' does not exist in the current context
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ·»åŠ  System å‘½åç©ºé—´
using System;

// ä½¿ç”¨å®Œæ•´ç±»å‹å
var lines = text.Split('\n', StringSplitOptions.RemoveEmptyEntries);
```

---

## ğŸš¨ è¿è¡Œæ—¶é”™è¯¯å¤„ç†

### 1. æ–‡ä»¶æ“ä½œé”™è¯¯

#### é—®é¢˜ï¼šæ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†ä¸å·¥ä½œ
```csharp
// é”™è¯¯çš„æ–¹å¼
var dialog = new OpenFileDialog();
var result = await dialog.ShowAsync(this);
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼ - ä½¿ç”¨ StorageProvider
private async void SelectFileButton_Click(object? sender, RoutedEventArgs e)
{
    try
    {
        var options = new FilePickerOpenOptions
        {
            Title = "é€‰æ‹©æ–‡æœ¬æ–‡ä»¶",
            AllowMultiple = false,
            FileTypeFilter = new[]
            {
                new FilePickerFileType("æ–‡æœ¬æ–‡ä»¶")
                {
                    Patterns = new[] { "*.txt" }
                }
            }
        };

        var files = await StorageProvider.OpenFilePickerAsync(options);
        
        if (files.Count > 0)
        {
            var file = files[0];
            // å¤„ç†æ–‡ä»¶
        }
    }
    catch (Exception ex)
    {
        // é”™è¯¯å¤„ç†
        StatusMessage = $"æ–‡ä»¶é€‰æ‹©å¤±è´¥ï¼š{ex.Message}";
    }
}
```

#### é—®é¢˜ï¼šæ–‡ä»¶è·¯å¾„è®¿é—®é”™è¯¯
```
System.UnauthorizedAccessException: Access to the path is denied
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// ä½¿ç”¨å¼‚æ­¥æ–‡ä»¶æ“ä½œ
public async Task<string> ReadFileAsync(string filePath)
{
    try
    {
        return await File.ReadAllTextAsync(filePath);
    }
    catch (UnauthorizedAccessException)
    {
        throw new FileServiceException("æ²¡æœ‰æƒé™è®¿é—®æ–‡ä»¶");
    }
    catch (FileNotFoundException)
    {
        throw new FileServiceException("æ–‡ä»¶ä¸å­˜åœ¨");
    }
    catch (IOException ex)
    {
        throw new FileServiceException($"æ–‡ä»¶è¯»å–é”™è¯¯: {ex.Message}");
    }
}
```

### 2. æ•°æ®ç»‘å®šé”™è¯¯

#### é—®é¢˜ï¼šç»‘å®šä¸æ›´æ–°
```csharp
// é”™è¯¯çš„æ–¹å¼ - æ²¡æœ‰å®ç° INotifyPropertyChanged
public class BadViewModel
{
    public string Status { get; set; } = "åˆå§‹çŠ¶æ€";
    
    public void UpdateStatus()
    {
        Status = "æ›´æ–°çŠ¶æ€"; // UI ä¸ä¼šæ›´æ–°
    }
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼ - å®ç° INotifyPropertyChanged
public class GoodViewModel : INotifyPropertyChanged
{
    private string _status = "åˆå§‹çŠ¶æ€";
    
    public string Status
    {
        get => _status;
        set
        {
            if (_status != value)
            {
                _status = value;
                OnPropertyChanged();
            }
        }
    }
    
    public void UpdateStatus()
    {
        Status = "æ›´æ–°çŠ¶æ€"; // UI ä¼šè‡ªåŠ¨æ›´æ–°
    }
    
    public event PropertyChangedEventHandler? PropertyChanged;
    
    protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

#### é—®é¢˜ï¼šé›†åˆç»‘å®šä¸å·¥ä½œ
```csharp
// é”™è¯¯çš„æ–¹å¼ - ä½¿ç”¨ List<T>
public List<TagInfo> Items { get; set; } = new();
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼ - ä½¿ç”¨ ObservableCollection<T>
public ObservableCollection<TagInfo> Items { get; set; } = new();

// æ›´æ–°é›†åˆæ—¶ UI ä¼šè‡ªåŠ¨æ›´æ–°
Items.Add(new TagInfo("æ–°æ ‡ç­¾", 1, new List<string>()));
Items.RemoveAt(0);
Items.Clear();
```

### 3. å†…å­˜æ³„æ¼é—®é¢˜

#### é—®é¢˜ï¼šäº‹ä»¶å¤„ç†å™¨æœªå–æ¶ˆè®¢é˜…
```csharp
// é”™è¯¯çš„æ–¹å¼ - å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
public class BadViewModel
{
    public BadViewModel()
    {
        SomeService.DataChanged += OnDataChanged;
    }
    
    // æ²¡æœ‰ Dispose æ–¹æ³•å–æ¶ˆè®¢é˜…
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼ - å®ç° IDisposable
public class GoodViewModel : INotifyPropertyChanged, IDisposable
{
    private bool _disposed = false;
    
    public GoodViewModel()
    {
        SomeService.DataChanged += OnDataChanged;
    }
    
    public void Dispose()
    {
        if (!_disposed)
        {
            SomeService.DataChanged -= OnDataChanged;
            _disposed = true;
        }
    }
    
    private void OnDataChanged(object? sender, EventArgs e)
    {
        if (_disposed) return;
        // å¤„ç†æ•°æ®å˜æ›´
    }
}
```

---

## ğŸ”— æ•°æ®ç»‘å®šé—®é¢˜

### 1. ç»‘å®šè·¯å¾„é”™è¯¯

#### é—®é¢˜ï¼šç»‘å®šè·¯å¾„ä¸å­˜åœ¨
```xml
<!-- é”™è¯¯çš„æ–¹å¼ - å±æ€§ä¸å­˜åœ¨ -->
<TextBlock Text="{Binding NonExistentProperty}"/>
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// ç¡®ä¿ ViewModel ä¸­æœ‰å¯¹åº”çš„å±æ€§
public class MainViewModel : INotifyPropertyChanged
{
    private string _statusMessage = string.Empty;
    
    public string StatusMessage
    {
        get => _statusMessage;
        set
        {
            _statusMessage = value;
            OnPropertyChanged();
        }
    }
}
```

#### é—®é¢˜ï¼šåµŒå¥—å±æ€§ç»‘å®šå¤±è´¥
```xml
<!-- é”™è¯¯çš„æ–¹å¼ - åµŒå¥—å±æ€§ä¸º null -->
<TextBlock Text="{Binding User.Profile.Name}"/>
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// ç¡®ä¿åµŒå¥—å±æ€§ä¸ä¸º null
public class MainViewModel
{
    private User _user = new User(); // ç¡®ä¿ä¸ä¸º null
    
    public User User
    {
        get => _user;
        set
        {
            _user = value ?? new User();
            OnPropertyChanged();
        }
    }
}

// æˆ–è€…åœ¨ç»‘å®šä¸­ä½¿ç”¨ç©ºå€¼æ£€æŸ¥
<TextBlock Text="{Binding User.Profile.Name, FallbackValue='æœªçŸ¥ç”¨æˆ·'}"/>
```

### 2. è½¬æ¢å™¨é—®é¢˜

#### é—®é¢˜ï¼šè½¬æ¢å™¨æœªæ³¨å†Œ
```xml
<!-- é”™è¯¯çš„æ–¹å¼ - è½¬æ¢å™¨æœªå®šä¹‰ -->
<TextBlock Visibility="{Binding IsVisible, Converter={StaticResource BoolToVisibilityConverter}}"/>
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- åœ¨èµ„æºä¸­å®šä¹‰è½¬æ¢å™¨ -->
<Window.Resources>
    <converters:BoolToVisibilityConverter x:Key="BoolToVisibilityConverter"/>
</Window.Resources>

<!-- æˆ–è€…ä½¿ç”¨å†…ç½®è½¬æ¢å™¨ -->
<TextBlock Visibility="{Binding IsVisible, Converter={x:Static BoolConverters.NotEqualTo}, ConverterParameter=False}"/>
```

### 3. åŒå‘ç»‘å®šé—®é¢˜

#### é—®é¢˜ï¼šåŒå‘ç»‘å®šä¸å·¥ä½œ
```xml
<!-- é”™è¯¯çš„æ–¹å¼ - å±æ€§æ²¡æœ‰ setter -->
<TextBox Text="{Binding ReadOnlyProperty, Mode=TwoWay}"/>
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// ç¡®ä¿å±æ€§æœ‰ setter
public string UserInput
{
    get => _userInput;
    set
    {
        _userInput = value;
        OnPropertyChanged();
    }
}
```

---

## ğŸ¨ UI å¸ƒå±€é—®é¢˜

### 1. å¸ƒå±€å®¹å™¨é—®é¢˜

#### é—®é¢˜ï¼šGrid å¸ƒå±€ä¸ç”Ÿæ•ˆ
```xml
<!-- é”™è¯¯çš„æ–¹å¼ - æ²¡æœ‰å®šä¹‰è¡Œåˆ— -->
<Grid>
    <Button Grid.Row="0" Grid.Column="0" Content="æŒ‰é’®"/>
</Grid>
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- æ­£ç¡®çš„æ–¹å¼ - å®šä¹‰è¡Œåˆ— -->
<Grid>
    <Grid.RowDefinitions>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="*"/>
    </Grid.RowDefinitions>
    
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="Auto"/>
        <ColumnDefinition Width="*"/>
    </Grid.ColumnDefinitions>
    
    <Button Grid.Row="0" Grid.Column="0" Content="æŒ‰é’®"/>
</Grid>
```

#### é—®é¢˜ï¼šStackPanel æ–¹å‘é”™è¯¯
```xml
<!-- é”™è¯¯çš„æ–¹å¼ - æ–¹å‘ä¸æ˜ç¡® -->
<StackPanel>
    <Button Content="æŒ‰é’®1"/>
    <Button Content="æŒ‰é’®2"/>
</StackPanel>
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- æ­£ç¡®çš„æ–¹å¼ - æ˜ç¡®æŒ‡å®šæ–¹å‘ -->
<StackPanel Orientation="Vertical" Spacing="10">
    <Button Content="æŒ‰é’®1"/>
    <Button Content="æŒ‰é’®2"/>
</StackPanel>
```

### 2. å°ºå¯¸å’Œè¾¹è·é—®é¢˜

#### é—®é¢˜ï¼šæ§ä»¶å°ºå¯¸ä¸æ­£ç¡®
```xml
<!-- é”™è¯¯çš„æ–¹å¼ - å°ºå¯¸å†²çª -->
<Button Width="100" Width="200" Content="æŒ‰é’®"/>
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- æ­£ç¡®çš„æ–¹å¼ - é¿å…å†²çª -->
<Button Width="100" Height="30" Content="æŒ‰é’®"/>

<!-- æˆ–è€…ä½¿ç”¨ MinWidth/MaxWidth -->
<Button MinWidth="100" MaxWidth="200" Content="æŒ‰é’®"/>
```

#### é—®é¢˜ï¼šè¾¹è·è®¾ç½®é”™è¯¯
```xml
<!-- é”™è¯¯çš„æ–¹å¼ - è¾¹è·æ ¼å¼é”™è¯¯ -->
<Button Margin="10,20,30" Content="æŒ‰é’®"/>
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- æ­£ç¡®çš„æ–¹å¼ - è¾¹è·æ ¼å¼ -->
<Button Margin="10" Content="æŒ‰é’®"/>           <!-- å››ä¸ªæ–¹å‘ç›¸åŒ -->
<Button Margin="10,20" Content="æŒ‰é’®"/>        <!-- ä¸Šä¸‹,å·¦å³ -->
<Button Margin="10,20,30,40" Content="æŒ‰é’®"/>  <!-- å·¦,ä¸Š,å³,ä¸‹ -->
```

---

## âš¡ æ€§èƒ½é—®é¢˜ä¼˜åŒ–

### 1. æ•°æ®ç»‘å®šæ€§èƒ½

#### é—®é¢˜ï¼šé¢‘ç¹çš„å±æ€§æ›´æ–°
```csharp
// é”™è¯¯çš„æ–¹å¼ - é¢‘ç¹æ›´æ–°
public void ProcessData()
{
    for (int i = 0; i < 1000; i++)
    {
        StatusMessage = $"å¤„ç†ä¸­... {i}"; // æ¯æ¬¡éƒ½ä¼šè§¦å‘ UI æ›´æ–°
    }
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼ - æ‰¹é‡æ›´æ–°
public void ProcessData()
{
    var progress = 0;
    var timer = new DispatcherTimer
    {
        Interval = TimeSpan.FromMilliseconds(100)
    };
    
    timer.Tick += (s, e) =>
    {
        if (progress < 1000)
        {
            StatusMessage = $"å¤„ç†ä¸­... {progress}";
            progress += 10;
        }
        else
        {
            timer.Stop();
            StatusMessage = "å¤„ç†å®Œæˆ";
        }
    };
    
    timer.Start();
}
```

#### é—®é¢˜ï¼šå¤§é‡æ•°æ®ç»‘å®š
```xml
<!-- é”™è¯¯çš„æ–¹å¼ - å¤§é‡æ•°æ®ç›´æ¥ç»‘å®š -->
<ListBox ItemsSource="{Binding LargeCollection}"/>
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- æ­£ç¡®çš„æ–¹å¼ - ä½¿ç”¨è™šæ‹ŸåŒ– -->
<ListBox ItemsSource="{Binding LargeCollection}"
         VirtualizationMode="Recycling"
         VirtualizationPanel="VirtualizingStackPanel"/>
```

### 2. å†…å­˜ä½¿ç”¨ä¼˜åŒ–

#### é—®é¢˜ï¼šå¤§å¯¹è±¡æœªåŠæ—¶é‡Šæ”¾
```csharp
// é”™è¯¯çš„æ–¹å¼ - å¤§å¯¹è±¡å¸¸é©»å†…å­˜
public class BadViewModel
{
    private byte[] _largeData = new byte[1000000]; // 1MB æ•°æ®
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼ - æŒ‰éœ€åŠ è½½å’Œé‡Šæ”¾
public class GoodViewModel : IDisposable
{
    private byte[]? _largeData;
    private bool _disposed = false;
    
    public byte[] GetLargeData()
    {
        if (_largeData == null)
        {
            _largeData = LoadLargeData();
        }
        return _largeData;
    }
    
    public void Dispose()
    {
        if (!_disposed)
        {
            _largeData = null; // é‡Šæ”¾å¤§å¯¹è±¡
            _disposed = true;
        }
    }
}
```

---

## ğŸ“¦ å‘å¸ƒéƒ¨ç½²é—®é¢˜

### 1. è¿è¡Œæ—¶é”™è¯¯

#### é—®é¢˜ï¼šç¼ºå°‘è¿è¡Œæ—¶
```
error: The application requires .NET 8.0 runtime
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```bash
# ä½¿ç”¨è‡ªåŒ…å«å‘å¸ƒ
dotnet publish --self-contained true --runtime win-x64

# æˆ–è€…å®‰è£…è¿è¡Œæ—¶
dotnet install dotnet-runtime-8.0
```

#### é—®é¢˜ï¼šå¹³å°ä¸å…¼å®¹
```
error: This application is not compatible with the current platform
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```bash
# æ£€æŸ¥ç›®æ ‡å¹³å°
dotnet publish --runtime win-x64    # Windows 64ä½
dotnet publish --runtime linux-x64  # Linux 64ä½
dotnet publish --runtime osx-x64    # macOS 64ä½
```

### 2. æ–‡ä»¶å¤§å°é—®é¢˜

#### é—®é¢˜ï¼šå‘å¸ƒæ–‡ä»¶è¿‡å¤§
```
å‘å¸ƒæ–‡ä»¶è¶…è¿‡ 200MB
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```bash
# ä½¿ç”¨æ¡†æ¶ä¾èµ–å‘å¸ƒ
dotnet publish --framework net8.0

# å¯ç”¨ IL ä¿®å‰ª
dotnet publish --property:PublishTrimmed=true

# ä½¿ç”¨ ReadyToRun
dotnet publish --property:PublishReadyToRun=true
```

### 3. ä¾èµ–é—®é¢˜

#### é—®é¢˜ï¼šç¼ºå°‘ä¾èµ–åº“
```
error: Could not load file or assembly 'SomeLibrary'
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- ç¡®ä¿æ‰€æœ‰ä¾èµ–éƒ½åœ¨é¡¹ç›®æ–‡ä»¶ä¸­ -->
<PackageReference Include="SomeLibrary" Version="1.0.0" />

<!-- æˆ–è€…ä½¿ç”¨è‡ªåŒ…å«å‘å¸ƒ -->
<PropertyGroup>
  <SelfContained>true</SelfContained>
</PropertyGroup>
```

---

## ğŸ” è°ƒè¯•æŠ€å·§

### 1. æ—¥å¿—è®°å½•

#### æ·»åŠ æ—¥å¿—æ”¯æŒ
```csharp
// ä½¿ç”¨ Microsoft.Extensions.Logging
public class MainViewModel
{
    private readonly ILogger<MainViewModel> _logger;
    
    public MainViewModel(ILogger<MainViewModel> logger)
    {
        _logger = logger;
    }
    
    public void ProcessData()
    {
        _logger.LogInformation("å¼€å§‹å¤„ç†æ•°æ®");
        
        try
        {
            // å¤„ç†é€»è¾‘
            _logger.LogInformation("æ•°æ®å¤„ç†å®Œæˆ");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æ•°æ®å¤„ç†å¤±è´¥");
        }
    }
}
```

#### é…ç½®æ—¥å¿—
```csharp
// Program.cs
using Microsoft.Extensions.Logging;

public static AppBuilder BuildAvaloniaApp()
{
    return AppBuilder.Configure<App>()
        .UsePlatformDetect()
        .LogToTrace()
        .LogToDebug();
}
```

### 2. æ–­ç‚¹è°ƒè¯•

#### è®¾ç½®æ–­ç‚¹
```csharp
public void ProcessText(string text)
{
    // åœ¨è¿™é‡Œè®¾ç½®æ–­ç‚¹
    var lines = text.Split('\n');
    
    foreach (var line in lines)
    {
        // æ¡ä»¶æ–­ç‚¹ï¼šline.Contains("M35_")
        if (line.StartsWith("M35_"))
        {
            // å¤„ç†é€»è¾‘
        }
    }
}
```

#### è°ƒè¯•è¾“å‡º
```csharp
// ä½¿ç”¨ Debug.WriteLine
using System.Diagnostics;

public void ProcessText(string text)
{
    Debug.WriteLine($"å¼€å§‹å¤„ç†æ–‡æœ¬ï¼Œé•¿åº¦: {text.Length}");
    
    var result = TextParser.ParseText(text);
    
    Debug.WriteLine($"è§£æå®Œæˆï¼Œæ‰¾åˆ° {result.TagInfos.Count} ä¸ªæ ‡ç­¾");
}
```

### 3. å¼‚å¸¸å¤„ç†

#### å…¨å±€å¼‚å¸¸å¤„ç†
```csharp
// App.axaml.cs
public override void OnFrameworkInitializationCompleted()
{
    // è®¾ç½®å…¨å±€å¼‚å¸¸å¤„ç†
    AppDomain.CurrentDomain.UnhandledException += OnUnhandledException;
    
    base.OnFrameworkInitializationCompleted();
}

private void OnUnhandledException(object sender, UnhandledExceptionEventArgs e)
{
    var exception = e.ExceptionObject as Exception;
    // è®°å½•å¼‚å¸¸
    System.Diagnostics.Debug.WriteLine($"æœªå¤„ç†çš„å¼‚å¸¸: {exception?.Message}");
}
```

---

## âœ… æœ€ä½³å®è·µ

### 1. ä»£ç ç»„ç»‡

#### é¡¹ç›®ç»“æ„
```
TagAnalyzer/
â”œâ”€â”€ Models/           # æ•°æ®æ¨¡å‹
â”œâ”€â”€ ViewModels/       # è§†å›¾æ¨¡å‹
â”œâ”€â”€ Views/           # è§†å›¾
â”œâ”€â”€ Services/        # æœåŠ¡
â”œâ”€â”€ Commands/        # å‘½ä»¤
â”œâ”€â”€ Converters/      # è½¬æ¢å™¨
â”œâ”€â”€ Validation/      # éªŒè¯è§„åˆ™
â””â”€â”€ Utils/          # å·¥å…·ç±»
```

#### å‘½åçº¦å®š
```csharp
// ç±»åä½¿ç”¨ PascalCase
public class MainWindowViewModel { }

// å±æ€§åä½¿ç”¨ PascalCase
public string StatusMessage { get; set; }

// å­—æ®µåä½¿ç”¨ camelCase
private string _statusMessage;

// æ–¹æ³•åä½¿ç”¨ PascalCase
public void ProcessData() { }

// å¸¸é‡ä½¿ç”¨ UPPER_CASE
public const string DEFAULT_FILE_PATH = "default.txt";
```

### 2. é”™è¯¯å¤„ç†

#### å¼‚å¸¸å¤„ç†ç­–ç•¥
```csharp
public async Task ProcessFileAsync(string filePath)
{
    try
    {
        // ä¸šåŠ¡é€»è¾‘
        var text = await File.ReadAllTextAsync(filePath);
        var result = TextParser.ParseText(text);
        
        // æ›´æ–° UI
        UpdateUI(result);
    }
    catch (FileNotFoundException)
    {
        StatusMessage = "æ–‡ä»¶ä¸å­˜åœ¨";
    }
    catch (UnauthorizedAccessException)
    {
        StatusMessage = "æ²¡æœ‰æƒé™è®¿é—®æ–‡ä»¶";
    }
    catch (Exception ex)
    {
        StatusMessage = $"å¤„ç†å¤±è´¥: {ex.Message}";
        _logger.LogError(ex, "æ–‡ä»¶å¤„ç†å¤±è´¥");
    }
}
```

### 3. æ€§èƒ½ä¼˜åŒ–

#### å¼‚æ­¥æ“ä½œ
```csharp
// ä½¿ç”¨å¼‚æ­¥æ–¹æ³•
public async Task<string> ReadFileAsync(string filePath)
{
    return await File.ReadAllTextAsync(filePath);
}

// é¿å…é˜»å¡ UI çº¿ç¨‹
public async Task ProcessLargeFileAsync(string filePath)
{
    IsProcessing = true;
    
    try
    {
        await Task.Run(() =>
        {
            // åœ¨åå°çº¿ç¨‹å¤„ç†å¤§æ–‡ä»¶
            ProcessLargeFile(filePath);
        });
    }
    finally
    {
        IsProcessing = false;
    }
}
```

#### å†…å­˜ç®¡ç†
```csharp
// å®ç° IDisposable
public class MainViewModel : INotifyPropertyChanged, IDisposable
{
    private bool _disposed = false;
    
    public void Dispose()
    {
        if (!_disposed)
        {
            // æ¸…ç†èµ„æº
            _tagInfos?.Clear();
            _timer?.Stop();
            
            _disposed = true;
        }
    }
}
```

---

## ğŸ¯ æ€»ç»“

å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆåŒ…æ‹¬ï¼š

1. **ç¼–è¯‘é”™è¯¯**ï¼šXAML è¯­æ³•ã€å‘½åç©ºé—´ã€ä¾èµ–é—®é¢˜
2. **è¿è¡Œæ—¶é”™è¯¯**ï¼šæ–‡ä»¶æ“ä½œã€æ•°æ®ç»‘å®šã€å†…å­˜æ³„æ¼
3. **æ•°æ®ç»‘å®š**ï¼šè·¯å¾„é”™è¯¯ã€è½¬æ¢å™¨ã€åŒå‘ç»‘å®š
4. **UI å¸ƒå±€**ï¼šå®¹å™¨é…ç½®ã€å°ºå¯¸è®¾ç½®ã€è¾¹è·é—®é¢˜
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šç»‘å®šæ€§èƒ½ã€å†…å­˜ä½¿ç”¨ã€å¼‚æ­¥æ“ä½œ
6. **å‘å¸ƒéƒ¨ç½²**ï¼šè¿è¡Œæ—¶ã€å¹³å°å…¼å®¹ã€æ–‡ä»¶å¤§å°
7. **è°ƒè¯•æŠ€å·§**ï¼šæ—¥å¿—è®°å½•ã€æ–­ç‚¹è°ƒè¯•ã€å¼‚å¸¸å¤„ç†
8. **æœ€ä½³å®è·µ**ï¼šä»£ç ç»„ç»‡ã€é”™è¯¯å¤„ç†ã€æ€§èƒ½ä¼˜åŒ–

é€šè¿‡æŒæ¡è¿™äº›é—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼Œå¯ä»¥é¿å…å¸¸è§çš„å¼€å‘é™·é˜±ï¼Œæé«˜å¼€å‘æ•ˆç‡å’Œä»£ç è´¨é‡ï¼

---

## ğŸš€ .NET 10 + C# 14 ç‰¹å®šé—®é¢˜

### 1. C# 14 è¯­æ³•é—®é¢˜

#### é—®é¢˜ï¼šé›†åˆè¡¨è¾¾å¼è¯­æ³•é”™è¯¯
```
error CS1003: Syntax error, '[' expected
```

**åŸå› åˆ†æ**ï¼š
- ç›®æ ‡æ¡†æ¶ä¸æ”¯æŒ C# 14
- è¯­è¨€ç‰ˆæœ¬è®¾ç½®é”™è¯¯

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- ç¡®ä¿é¡¹ç›®æ–‡ä»¶é…ç½®æ­£ç¡® -->
<PropertyGroup>
  <TargetFramework>net10.0</TargetFramework>
  <LangVersion>14</LangVersion>
  <EnablePreviewFeatures>true</EnablePreviewFeatures>
</PropertyGroup>
```

#### é—®é¢˜ï¼šå¿…éœ€æˆå‘˜åˆå§‹åŒ–é”™è¯¯
```
error CS9035: Required member 'Tag' must be set in the object initializer
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// é”™è¯¯çš„æ–¹å¼
var tagInfo = new TagInfo(); // ç¼ºå°‘å¿…éœ€æˆå‘˜

// æ­£ç¡®çš„æ–¹å¼
var tagInfo = new TagInfo("æŠ½æ³£", 5); // é€šè¿‡æ„é€ å‡½æ•°è®¾ç½®å¿…éœ€æˆå‘˜

// æˆ–è€…ä½¿ç”¨å¯¹è±¡åˆå§‹åŒ–å™¨
var tagInfo = new TagInfo("æŠ½æ³£", 5)
{
    SourceIds = ["M35_230001", "M35_230002"]
};
```

#### é—®é¢˜ï¼šæ–‡ä»¶æœ¬åœ°ç±»å‹å†²çª
```
error CS0101: The namespace already contains a definition for 'Helper'
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// File1.cs
file class Helper
{
    public static void Process() { }
}

// File2.cs
file class Helper  // ä½¿ç”¨ file å…³é”®å­—ï¼Œä¸ä¼šå†²çª
{
    public static void Process() { }
}
```

### 2. .NET 10 è¿è¡Œæ—¶é—®é¢˜

#### é—®é¢˜ï¼šç›®æ ‡æ¡†æ¶ä¸åŒ¹é…
```
error NETSDK1045: The current .NET SDK does not support targeting .NET 10.0
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```bash
# æ£€æŸ¥ SDK ç‰ˆæœ¬
dotnet --version

# å®‰è£… .NET 10 SDK
dotnet install dotnet-sdk-10.0

# æˆ–è€…ä½¿ç”¨é¢„è§ˆç‰ˆæœ¬
dotnet install dotnet-sdk-10.0-preview
```

#### é—®é¢˜ï¼šé¢„è§ˆç‰¹æ€§ä¸å¯ç”¨
```
error CS8652: The feature 'collection expressions' is currently in Preview
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- å¯ç”¨é¢„è§ˆç‰¹æ€§ -->
<PropertyGroup>
  <EnablePreviewFeatures>true</EnablePreviewFeatures>
  <AnalysisLevel>latest</AnalysisLevel>
</PropertyGroup>
```

### 3. æ¨¡å¼åŒ¹é…é—®é¢˜

#### é—®é¢˜ï¼šåˆ—è¡¨æ¨¡å¼è¯­æ³•é”™è¯¯
```csharp
// é”™è¯¯çš„æ–¹å¼
return lines switch
{
    [] => "ç©º",
    [var first] => $"å•è¡Œ: {first}",
    [var first, var second] => $"ä¸¤è¡Œ: {first}, {second}"
    // ç¼ºå°‘é»˜è®¤æƒ…å†µ
};
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼
return lines switch
{
    [] => "ç©º",
    [var first] => $"å•è¡Œ: {first}",
    [var first, var second] => $"ä¸¤è¡Œ: {first}, {second}",
    _ => "å¤šè¡Œ" // æ·»åŠ é»˜è®¤æƒ…å†µ
};
```

#### é—®é¢˜ï¼šåˆ‡ç‰‡æ¨¡å¼ä½¿ç”¨é”™è¯¯
```csharp
// é”™è¯¯çš„æ–¹å¼ - åœ¨éæ•°ç»„ç±»å‹ä¸Šä½¿ç”¨
var result = text switch
{
    [var first, .. var rest] => $"å¼€å§‹: {first}" // text æ˜¯ stringï¼Œä¸æ˜¯æ•°ç»„
};
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼
var chars = text.ToCharArray();
var result = chars switch
{
    [var first, .. var rest] => $"å¼€å§‹: {first}",
    _ => "ç©ºå­—ç¬¦ä¸²"
};

// æˆ–è€…ä½¿ç”¨ Span<char>
var span = text.AsSpan();
if (span.Length > 0)
{
    var first = span[0];
    var rest = span[1..];
}
```

### 4. å¼‚æ­¥æµé—®é¢˜

#### é—®é¢˜ï¼šIAsyncEnumerable ä½¿ç”¨é”™è¯¯
```csharp
// é”™è¯¯çš„æ–¹å¼ - ç¼ºå°‘ CancellationToken
public async IAsyncEnumerable<string> ProcessFilesAsync(IEnumerable<string> filePaths)
{
    foreach (var filePath in filePaths)
    {
        yield return await ProcessFile(filePath); // ç¼ºå°‘ cancellationToken
    }
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼
public async IAsyncEnumerable<string> ProcessFilesAsync(
    IEnumerable<string> filePaths,
    [EnumeratorCancellation] CancellationToken cancellationToken = default)
{
    foreach (var filePath in filePaths)
    {
        cancellationToken.ThrowIfCancellationRequested();
        yield return await ProcessFile(filePath, cancellationToken);
    }
}
```

#### é—®é¢˜ï¼šConfigureAwait ä½¿ç”¨ä¸å½“
```csharp
// é”™è¯¯çš„æ–¹å¼ - åœ¨ UI çº¿ç¨‹ä¸­ä½¿ç”¨ ConfigureAwait(false)
public async Task UpdateUIAsync()
{
    var data = await GetDataAsync().ConfigureAwait(false); // å¯èƒ½å¯¼è‡´è·¨çº¿ç¨‹è®¿é—®
    UpdateControls(data); // UI æ›´æ–°å¯èƒ½å¤±è´¥
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼ - UI çº¿ç¨‹ä¸­ä¸ä½¿ç”¨ ConfigureAwait(false)
public async Task UpdateUIAsync()
{
    var data = await GetDataAsync(); // ä¿æŒ UI ä¸Šä¸‹æ–‡
    UpdateControls(data);
}

// æˆ–è€…åœ¨åå°çº¿ç¨‹ä¸­ä½¿ç”¨
public async Task ProcessDataAsync()
{
    await Task.Run(async () =>
    {
        var data = await GetDataAsync().ConfigureAwait(false); // åå°çº¿ç¨‹ä¸­ä½¿ç”¨
        ProcessData(data);
    });
}
```

### 5. æ€§èƒ½ä¼˜åŒ–é—®é¢˜

#### é—®é¢˜ï¼šSpan<T> ä½¿ç”¨é”™è¯¯
```csharp
// é”™è¯¯çš„æ–¹å¼ - åœ¨å¼‚æ­¥æ–¹æ³•ä¸­ä½¿ç”¨ Span<T>
public async Task<string> ProcessTextAsync(string text)
{
    Span<char> span = text.AsSpan(); // Span<T> ä¸èƒ½è·¨è¶Šå¼‚æ­¥è¾¹ç•Œ
    await SomeAsyncOperation();
    return span.ToString(); // å¯èƒ½ä¸å®‰å…¨
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼ - ä½¿ç”¨ Memory<T>
public async Task<string> ProcessTextAsync(string text)
{
    Memory<char> memory = text.AsMemory();
    await SomeAsyncOperation();
    return memory.Span.ToString();
}

// æˆ–è€…åœ¨åŒæ­¥æ–¹æ³•ä¸­ä½¿ç”¨ Span<T>
public string ProcessText(string text)
{
    Span<char> span = text.AsSpan();
    // åŒæ­¥å¤„ç†
    return span.ToString();
}
```

#### é—®é¢˜ï¼šè®°å½•ç±»å‹æ€§èƒ½é—®é¢˜
```csharp
// é”™è¯¯çš„æ–¹å¼ - é¢‘ç¹åˆ›å»ºè®°å½•ç±»å‹
public void ProcessData(List<string> items)
{
    foreach (var item in items)
    {
        var result = new ParseResult(item, DateTime.Now, []); // é¢‘ç¹åˆ†é…
        ProcessResult(result);
    }
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼ - é‡ç”¨è®°å½•ç±»å‹æˆ–ä½¿ç”¨ç»“æ„ä½“
public void ProcessData(List<string> items)
{
    var timestamp = DateTime.Now;
    foreach (var item in items)
    {
        var result = new ParseResult(item, timestamp, []); // é‡ç”¨æ—¶é—´æˆ³
        ProcessResult(result);
    }
}

// æˆ–è€…ä½¿ç”¨ç»“æ„ä½“è®°å½•
public readonly record struct ParseResultStruct(string Item, DateTime Timestamp);
```

### 6. è°ƒè¯•å’Œè¯Šæ–­é—®é¢˜

#### é—®é¢˜ï¼šè°ƒç”¨æ–¹ä¿¡æ¯ä¸å‡†ç¡®
```csharp
// é”™è¯¯çš„æ–¹å¼ - ç¼ºå°‘è°ƒç”¨æ–¹ä¿¡æ¯å±æ€§
public void LogInfo(string message)
{
    Console.WriteLine(message); // æ— æ³•çŸ¥é“è°ƒç”¨ä½ç½®
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–¹å¼ - ä½¿ç”¨è°ƒç”¨æ–¹ä¿¡æ¯å±æ€§
public void LogInfo(string message,
    [CallerFilePath] string filePath = "",
    [CallerLineNumber] int lineNumber = 0,
    [CallerMemberName] string memberName = "")
{
    var fileName = Path.GetFileName(filePath);
    Console.WriteLine($"[{fileName}:{lineNumber}] {memberName}: {message}");
}
```

### 7. æœ€ä½³å®è·µå»ºè®®

#### C# 14 ç‰¹æ€§ä½¿ç”¨å»ºè®®
```csharp
// 1. åˆç†ä½¿ç”¨é›†åˆè¡¨è¾¾å¼
public class DataProcessor
{
    // å¥½çš„ç”¨æ³• - ç®€å•é›†åˆåˆå§‹åŒ–
    private readonly List<string> _extensions = ["txt", "csv", "json"];
    
    // é¿å…è¿‡åº¦ä½¿ç”¨ - å¤æ‚é€»è¾‘
    public List<string> ProcessData()
    {
        var result = [];
        foreach (var item in _data)
        {
            if (item.IsValid)
                result.Add(item.Name);
        }
        return result; // ä¸è¦å¼ºåˆ¶ä½¿ç”¨é›†åˆè¡¨è¾¾å¼
    }
}

// 2. æ¨¡å¼åŒ¹é…ä½¿ç”¨å»ºè®®
public string ProcessInput(object input)
{
    return input switch
    {
        string s when s.Length > 0 => $"å­—ç¬¦ä¸²: {s}",
        int i when i > 0 => $"æ­£æ•°: {i}",
        null => "ç©ºå€¼",
        _ => "æœªçŸ¥ç±»å‹"
    };
}

// 3. å¿…éœ€æˆå‘˜ä½¿ç”¨å»ºè®®
public class Configuration
{
    // å¿…éœ€çš„æ ¸å¿ƒé…ç½®
    public required string DatabaseConnection { get; set; }
    public required string ApiKey { get; set; }
    
    // å¯é€‰é…ç½®
    public int Timeout { get; set; } = 30;
    public bool EnableLogging { get; set; } = true;
}
```

#### .NET 10 æ€§èƒ½å»ºè®®
```csharp
// 1. ä½¿ç”¨ç°ä»£å¼‚æ­¥æ¨¡å¼
public class ModernService
{
    public async Task<Result> ProcessAsync(CancellationToken cancellationToken = default)
    {
        await using var resource = GetResource();
        return await ProcessResourceAsync(resource, cancellationToken);
    }
}

// 2. åˆç†ä½¿ç”¨ Span<T> å’Œ Memory<T>
public class TextProcessor
{
    public ReadOnlySpan<char> ExtractTag(ReadOnlySpan<char> text)
    {
        var start = text.IndexOf('ã€');
        if (start == -1) return ReadOnlySpan<char>.Empty;
        
        var end = text.IndexOf('ã€‘', start);
        if (end == -1) return ReadOnlySpan<char>.Empty;
        
        return text.Slice(start + 1, end - start - 1);
    }
}
```

### 8. æ€»ç»“

.NET 10 + C# 14 ç‰¹å®šé—®é¢˜ä¸»è¦åŒ…æ‹¬ï¼š

1. **è¯­æ³•é—®é¢˜**ï¼šé›†åˆè¡¨è¾¾å¼ã€å¿…éœ€æˆå‘˜ã€æ–‡ä»¶æœ¬åœ°ç±»å‹
2. **è¿è¡Œæ—¶é—®é¢˜**ï¼šç›®æ ‡æ¡†æ¶ã€é¢„è§ˆç‰¹æ€§
3. **æ¨¡å¼åŒ¹é…**ï¼šåˆ—è¡¨æ¨¡å¼ã€åˆ‡ç‰‡æ¨¡å¼è¯­æ³•
4. **å¼‚æ­¥æµ**ï¼šIAsyncEnumerableã€CancellationToken
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šSpan<T>ã€Memory<T>ã€è®°å½•ç±»å‹
6. **è°ƒè¯•è¯Šæ–­**ï¼šè°ƒç”¨æ–¹ä¿¡æ¯ã€æ—¥å¿—è®°å½•
7. **æœ€ä½³å®è·µ**ï¼šç‰¹æ€§ä½¿ç”¨å»ºè®®ã€æ€§èƒ½å»ºè®®

æŒæ¡è¿™äº›é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆï¼Œå¯ä»¥æ›´å¥½åœ°åˆ©ç”¨ .NET 10 å’Œ C# 14 çš„æ–°ç‰¹æ€§ï¼Œå¼€å‘å‡ºæ›´é«˜æ•ˆã€æ›´ç°ä»£çš„åº”ç”¨ç¨‹åºï¼

---

## ğŸš€ æ‰¹é‡å¤„ç†åŠŸèƒ½ç›¸å…³é—®é¢˜

### 1. æ–‡ä»¶å¤¹é€‰æ‹©é—®é¢˜

#### é—®é¢˜ï¼šæ–‡ä»¶å¤¹é€‰æ‹©å¯¹è¯æ¡†æ— æ³•æ‰“å¼€
```
System.ArgumentException: æ–‡ä»¶å¤¹é€‰æ‹©å¤±è´¥
```

**åŸå› åˆ†æ**ï¼š
- StorageProvider æœªæ­£ç¡®åˆå§‹åŒ–
- æƒé™ä¸è¶³
- å¹³å°ä¸æ”¯æŒæ–‡ä»¶å¤¹é€‰æ‹©

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„æ–‡ä»¶å¤¹é€‰æ‹©å®ç°
private async void SelectFolderButton_Click(object? sender, RoutedEventArgs e)
{
    try
    {
        var topLevel = TopLevel.GetTopLevel(this);
        if (topLevel?.StorageProvider == null)
        {
            StatusMessage = "å­˜å‚¨æä¾›ç¨‹åºæœªåˆå§‹åŒ–";
            return;
        }

        var options = new FolderPickerOpenOptions
        {
            Title = "é€‰æ‹©åŒ…å«txtæ–‡ä»¶çš„æ–‡ä»¶å¤¹",
            AllowMultiple = false
        };

        var folders = await topLevel.StorageProvider.OpenFolderPickerAsync(options);
        
        if (folders.Count > 0)
        {
            var folder = folders[0];
            await _viewModel.ProcessFolderAsync(folder.Path.LocalPath);
        }
    }
    catch (Exception ex)
    {
        StatusMessage = $"æ–‡ä»¶å¤¹é€‰æ‹©å¤±è´¥ï¼š{ex.Message}";
    }
}
```

#### é—®é¢˜ï¼šæ–‡ä»¶å¤¹è·¯å¾„åŒ…å«ç‰¹æ®Šå­—ç¬¦
```
System.IO.DirectoryNotFoundException: è·¯å¾„åŒ…å«æ— æ•ˆå­—ç¬¦
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// è·¯å¾„éªŒè¯å’Œå¤„ç†
private bool IsValidPath(string path)
{
    try
    {
        var invalidChars = Path.GetInvalidPathChars();
        return !path.Any(c => invalidChars.Contains(c));
    }
    catch
    {
        return false;
    }
}

private async Task ProcessFolderAsync(string folderPath)
{
    if (!IsValidPath(folderPath))
    {
        StatusMessage = "æ–‡ä»¶å¤¹è·¯å¾„åŒ…å«æ— æ•ˆå­—ç¬¦";
        return;
    }
    
    if (!Directory.Exists(folderPath))
    {
        StatusMessage = "æ–‡ä»¶å¤¹ä¸å­˜åœ¨";
        return;
    }
    
    // ç»§ç»­å¤„ç†...
}
```

### 2. æ–‡ä»¶æ‰«æé—®é¢˜

#### é—®é¢˜ï¼šæ‰«æå¤§é‡æ–‡ä»¶æ—¶å†…å­˜æº¢å‡º
```
System.OutOfMemoryException: å†…å­˜ä¸è¶³
```

**åŸå› åˆ†æ**ï¼š
- ä¸€æ¬¡æ€§åŠ è½½æ‰€æœ‰æ–‡ä»¶è·¯å¾„
- æ–‡ä»¶å†…å®¹è¿‡å¤§
- æ²¡æœ‰é™åˆ¶æ–‡ä»¶æ•°é‡

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// åˆ†æ‰¹æ‰«ææ–‡ä»¶
private async Task ProcessLargeFolderAsync(string folderPath)
{
    const int maxFilesPerBatch = 100;
    
    try
    {
        // å…ˆè·å–æ–‡ä»¶æ€»æ•°
        var allFiles = Directory.GetFiles(folderPath, "*.txt", SearchOption.AllDirectories);
        TotalFiles = allFiles.Length;
        
        if (TotalFiles > maxFilesPerBatch)
        {
            // åˆ†æ‰¹å¤„ç†
            await ProcessInBatches(allFiles, maxFilesPerBatch);
        }
        else
        {
            // ç›´æ¥å¤„ç†
            await ProcessDirectly(allFiles);
        }
    }
    catch (Exception ex)
    {
        StatusMessage = $"æ–‡ä»¶æ‰«æå¤±è´¥ï¼š{ex.Message}";
    }
}

private async Task ProcessInBatches(string[] files, int batchSize)
{
    var allResults = new Dictionary<string, TagInfoViewModel>();
    
    for (int i = 0; i < files.Length; i += batchSize)
    {
        var batch = files.Skip(i).Take(batchSize);
        var batchResults = await ProcessBatch(batch);
        
        MergeBatchResults(allResults, batchResults);
        
        // å¼ºåˆ¶åƒåœ¾å›æ”¶
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
    
    UpdateUIWithResults(allResults);
}
```

#### é—®é¢˜ï¼šæ–‡ä»¶è®¿é—®æƒé™ä¸è¶³
```
System.UnauthorizedAccessException: è®¿é—®è¢«æ‹’ç»
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æƒé™æ£€æŸ¥å’Œé”™è¯¯å¤„ç†
private async Task<List<string>> ScanFilesWithPermissionCheck(string folderPath)
{
    var files = new List<string>();
    
    try
    {
        var txtFiles = Directory.GetFiles(folderPath, "*.txt", SearchOption.AllDirectories);
        
        foreach (var file in txtFiles)
        {
            try
            {
                // æ£€æŸ¥æ–‡ä»¶è®¿é—®æƒé™
                using var stream = File.OpenRead(file);
                files.Add(file);
            }
            catch (UnauthorizedAccessException)
            {
                StatusMessage = $"è·³è¿‡æ— æƒé™æ–‡ä»¶: {Path.GetFileName(file)}";
                continue;
            }
            catch (IOException ex)
            {
                StatusMessage = $"è·³è¿‡æ— æ³•è®¿é—®çš„æ–‡ä»¶: {Path.GetFileName(file)} - {ex.Message}";
                continue;
            }
        }
    }
    catch (Exception ex)
    {
        StatusMessage = $"æ‰«ææ–‡ä»¶å¤¹å¤±è´¥: {ex.Message}";
    }
    
    return files;
}
```

### 3. è¿›åº¦æ˜¾ç¤ºé—®é¢˜

#### é—®é¢˜ï¼šè¿›åº¦æ¡ä¸æ›´æ–°
```
è¿›åº¦æ¡æ˜¾ç¤ºä¸º0%æˆ–100%ï¼Œä¸æ˜¾ç¤ºä¸­é—´è¿›åº¦
```

**åŸå› åˆ†æ**ï¼š
- UIçº¿ç¨‹é˜»å¡
- æ•°æ®ç»‘å®šæœªæ­£ç¡®è®¾ç½®
- è¿›åº¦æ›´æ–°é¢‘ç‡è¿‡é«˜

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„è¿›åº¦æ›´æ–°
public async Task ProcessFolderAsync(string folderPath)
{
    IsProcessing = true;
    ProcessedFiles = 0;
    TotalFiles = 0;
    
    try
    {
        var files = await ScanTxtFilesAsync(folderPath);
        TotalFiles = files.Length;
        
        foreach (var filePath in files)
        {
            // å¤„ç†æ–‡ä»¶
            await ProcessSingleFile(filePath);
            
            // æ›´æ–°è¿›åº¦
            ProcessedFiles++;
            
            // è®©UIæœ‰æœºä¼šæ›´æ–°
            await Task.Delay(1);
        }
    }
    finally
    {
        IsProcessing = false;
    }
}

// XAMLä¸­çš„æ­£ç¡®ç»‘å®š
<ProgressBar Value="{Binding ProcessedFiles}" 
             Maximum="{Binding TotalFiles}"
             IsVisible="{Binding TotalFiles}"/>
```

#### é—®é¢˜ï¼šè¿›åº¦ä¿¡æ¯æ˜¾ç¤ºä¸å‡†ç¡®
```
è¿›åº¦ç™¾åˆ†æ¯”è®¡ç®—é”™è¯¯æˆ–æ˜¾ç¤ºå¼‚å¸¸
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// è®¡ç®—å±æ€§å®ç°
public string ProgressMessage
{
    get
    {
        if (_totalFiles <= 0) return string.Empty;
        
        var percentage = Math.Min(100.0, _processedFiles * 100.0 / _totalFiles);
        return $"è¿›åº¦: {_processedFiles}/{_totalFiles} ({percentage:F1}%)";
    }
}

// ç¡®ä¿å±æ€§æ›´æ–°é€šçŸ¥
public int ProcessedFiles
{
    get => _processedFiles;
    set
    {
        _processedFiles = value;
        OnPropertyChanged();
        OnPropertyChanged(nameof(ProgressMessage)); // è§¦å‘è®¡ç®—å±æ€§æ›´æ–°
    }
}
```

### 4. æ•°æ®åˆå¹¶é—®é¢˜

#### é—®é¢˜ï¼šæ ‡ç­¾æ•°æ®é‡å¤æˆ–ä¸¢å¤±
```
ç›¸åŒæ ‡ç­¾çš„è®¡æ•°ä¸æ­£ç¡®ï¼Œæˆ–æŸäº›æ ‡ç­¾ä¸¢å¤±
```

**åŸå› åˆ†æ**ï¼š
- å­—å…¸é”®å€¼ä¸åŒ¹é…
- æ•°æ®åˆå¹¶é€»è¾‘é”™è¯¯
- çº¿ç¨‹å®‰å…¨é—®é¢˜

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// çº¿ç¨‹å®‰å…¨çš„æ•°æ®åˆå¹¶
private readonly object _mergeLock = new object();

private void MergeResults(Dictionary<string, TagInfoViewModel> allTagInfos, 
                         List<TagInfo> results, string filePath)
{
    lock (_mergeLock)
    {
        foreach (var result in results)
        {
            var key = result.Tag.ToLowerInvariant(); // ç»Ÿä¸€é”®å€¼æ ¼å¼
            
            if (!allTagInfos.ContainsKey(key))
            {
                allTagInfos[key] = new TagInfoViewModel
                {
                    Tag = result.Tag, // ä¿æŒåŸå§‹å¤§å°å†™
                    Count = 0,
                    SourceIds = string.Empty,
                    SourceFiles = string.Empty
                };
            }
            
            var existing = allTagInfos[key];
            existing.Count += result.Count;
            
            // åˆå¹¶æ¥æºID
            MergeSourceIds(existing, result.SourceIds);
            
            // åˆå¹¶æ¥æºæ–‡ä»¶
            MergeSourceFiles(existing, filePath);
        }
    }
}

private void MergeSourceIds(TagInfoViewModel existing, List<string> newIds)
{
    if (string.IsNullOrEmpty(existing.SourceIds))
    {
        existing.SourceIds = string.Join(", ", newIds);
    }
    else
    {
        var existingIds = existing.SourceIds.Split(", ", StringSplitOptions.RemoveEmptyEntries).ToHashSet();
        existingIds.UnionWith(newIds);
        existing.SourceIds = string.Join(", ", existingIds);
    }
}
```

#### é—®é¢˜ï¼šå†…å­˜ä½¿ç”¨è¿‡é«˜
```
å¤„ç†å¤§é‡æ–‡ä»¶æ—¶å†…å­˜å ç”¨è¿‡é«˜
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// å†…å­˜ä¼˜åŒ–çš„æ•°æ®å¤„ç†
public class MemoryOptimizedProcessor
{
    private const int MaxMemoryFiles = 50;
    
    public async Task<Dictionary<string, TagInfoViewModel>> ProcessFilesAsync(
        IEnumerable<string> filePaths)
    {
        var results = new Dictionary<string, TagInfoViewModel>();
        var processedCount = 0;
        
        foreach (var filePath in filePaths)
        {
            try
            {
                // å¤„ç†å•ä¸ªæ–‡ä»¶
                var fileResults = await ProcessSingleFileAsync(filePath);
                MergeResults(results, fileResults, filePath);
                
                processedCount++;
                
                // å®šæœŸæ¸…ç†å†…å­˜
                if (processedCount % MaxMemoryFiles == 0)
                {
                    GC.Collect();
                    GC.WaitForPendingFinalizers();
                }
            }
            catch (Exception ex)
            {
                // è®°å½•é”™è¯¯ä½†ç»§ç»­å¤„ç†
                Console.WriteLine($"å¤„ç†æ–‡ä»¶å¤±è´¥ {filePath}: {ex.Message}");
            }
        }
        
        return results;
    }
    
    private async Task<List<TagInfo>> ProcessSingleFileAsync(string filePath)
    {
        // ä½¿ç”¨æµå¼è¯»å–å¤§æ–‡ä»¶
        if (new FileInfo(filePath).Length > 10 * 1024 * 1024) // 10MB
        {
            return await ProcessLargeFileAsync(filePath);
        }
        else
        {
            var content = await File.ReadAllTextAsync(filePath);
            return TextParser.ParseText(content);
        }
    }
}
```

### 5. å¼‚æ­¥å¤„ç†é—®é¢˜

#### é—®é¢˜ï¼šUIçº¿ç¨‹é˜»å¡
```
æ‰¹é‡å¤„ç†æ—¶ç•Œé¢å¡æ­»ï¼Œæ— æ³•å“åº”ç”¨æˆ·æ“ä½œ
```

**åŸå› åˆ†æ**ï¼š
- åœ¨UIçº¿ç¨‹ä¸­æ‰§è¡Œè€—æ—¶æ“ä½œ
- æ²¡æœ‰ä½¿ç”¨å¼‚æ­¥æ–¹æ³•
- ç¼ºå°‘å–æ¶ˆæœºåˆ¶

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ­£ç¡®çš„å¼‚æ­¥å¤„ç†
public async Task ProcessFolderAsync(string folderPath, CancellationToken cancellationToken = default)
{
    IsProcessing = true;
    
    try
    {
        var files = await ScanTxtFilesAsync(folderPath);
        TotalFiles = files.Length;
        
        foreach (var filePath in files)
        {
            // æ£€æŸ¥å–æ¶ˆè¯·æ±‚
            cancellationToken.ThrowIfCancellationRequested();
            
            // å¼‚æ­¥å¤„ç†æ–‡ä»¶
            await ProcessSingleFileAsync(filePath, cancellationToken);
            
            // æ›´æ–°è¿›åº¦
            ProcessedFiles++;
        }
    }
    catch (OperationCanceledException)
    {
        StatusMessage = "å¤„ç†å·²å–æ¶ˆ";
    }
    catch (Exception ex)
    {
        StatusMessage = $"å¤„ç†å¤±è´¥: {ex.Message}";
    }
    finally
    {
        IsProcessing = false;
    }
}

// æ·»åŠ å–æ¶ˆæŒ‰é’®
private CancellationTokenSource? _cancellationTokenSource;

private async void SelectFolderButton_Click(object? sender, RoutedEventArgs e)
{
    if (_viewModel.IsProcessing)
    {
        // å–æ¶ˆå¤„ç†
        _cancellationTokenSource?.Cancel();
        return;
    }
    
    _cancellationTokenSource = new CancellationTokenSource();
    await _viewModel.ProcessFolderAsync(folderPath, _cancellationTokenSource.Token);
}
```

#### é—®é¢˜ï¼šå¼‚æ­¥æ–¹æ³•å¼‚å¸¸å¤„ç†
```
å¼‚æ­¥æ–¹æ³•ä¸­çš„å¼‚å¸¸æ²¡æœ‰è¢«æ­£ç¡®æ•è·
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// å®Œæ•´çš„å¼‚å¸¸å¤„ç†
public async Task ProcessFolderAsync(string folderPath)
{
    IsProcessing = true;
    
    try
    {
        await ProcessFolderInternalAsync(folderPath);
    }
    catch (AggregateException ex)
    {
        // å¤„ç†èšåˆå¼‚å¸¸
        var innerExceptions = ex.InnerExceptions;
        var errorMessages = innerExceptions.Select(e => e.Message).Distinct();
        StatusMessage = $"å¤„ç†å¤±è´¥: {string.Join("; ", errorMessages)}";
    }
    catch (Exception ex)
    {
        // å¤„ç†å…¶ä»–å¼‚å¸¸
        StatusMessage = $"å¤„ç†å¤±è´¥: {ex.Message}";
    }
    finally
    {
        IsProcessing = false;
    }
}

private async Task ProcessFolderInternalAsync(string folderPath)
{
    var files = await ScanTxtFilesAsync(folderPath);
    TotalFiles = files.Length;
    
    var tasks = files.Select(async filePath =>
    {
        try
        {
            return await ProcessSingleFileAsync(filePath);
        }
        catch (Exception ex)
        {
            // è®°å½•å•ä¸ªæ–‡ä»¶çš„é”™è¯¯
            Console.WriteLine($"å¤„ç†æ–‡ä»¶å¤±è´¥ {filePath}: {ex.Message}");
            return null;
        }
    });
    
    var results = await Task.WhenAll(tasks);
    
    // åˆå¹¶ç»“æœ
    var allTagInfos = new Dictionary<string, TagInfoViewModel>();
    foreach (var result in results.Where(r => r != null))
    {
        MergeResults(allTagInfos, result, "");
    }
    
    UpdateUIWithResults(allTagInfos);
}
```

### 6. æ€§èƒ½ä¼˜åŒ–é—®é¢˜

#### é—®é¢˜ï¼šå¤„ç†é€Ÿåº¦è¿‡æ…¢
```
æ‰¹é‡å¤„ç†å¤§é‡æ–‡ä»¶æ—¶é€Ÿåº¦å¾ˆæ…¢
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// å¹¶è¡Œå¤„ç†ä¼˜åŒ–
public async Task ProcessFolderParallelAsync(string folderPath)
{
    var files = await ScanTxtFilesAsync(folderPath);
    TotalFiles = files.Length;
    
    // é™åˆ¶å¹¶å‘æ•°é‡
    var semaphore = new SemaphoreSlim(Environment.ProcessorCount);
    
    var tasks = files.Select(async filePath =>
    {
        await semaphore.WaitAsync();
        try
        {
            return await ProcessSingleFileAsync(filePath);
        }
        finally
        {
            semaphore.Release();
        }
    });
    
    var results = await Task.WhenAll(tasks);
    
    // åˆå¹¶ç»“æœ
    var allTagInfos = new Dictionary<string, TagInfoViewModel>();
    foreach (var result in results.Where(r => r != null))
    {
        MergeResults(allTagInfos, result, "");
    }
    
    UpdateUIWithResults(allTagInfos);
}

// ä½¿ç”¨ ConfigureAwait(false) ä¼˜åŒ–
private async Task<List<TagInfo>> ProcessSingleFileAsync(string filePath)
{
    var content = await File.ReadAllTextAsync(filePath).ConfigureAwait(false);
    return await Task.Run(() => TextParser.ParseText(content)).ConfigureAwait(false);
}
```

#### é—®é¢˜ï¼šå†…å­˜æ³„æ¼
```
é•¿æ—¶é—´è¿è¡Œåå†…å­˜å ç”¨æŒç»­å¢é•¿
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// å†…å­˜æ³„æ¼é¢„é˜²
public class MemoryLeakPrevention
{
    private readonly Timer _memoryCleanupTimer;
    
    public MemoryLeakPrevention()
    {
        // å®šæœŸæ¸…ç†å†…å­˜
        _memoryCleanupTimer = new Timer(CleanupMemory, null, TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(5));
    }
    
    private void CleanupMemory(object? state)
    {
        if (!IsProcessing)
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();
        }
    }
    
    public void Dispose()
    {
        _memoryCleanupTimer?.Dispose();
    }
}

// åœ¨ViewModelä¸­å®ç°IDisposable
public class MainWindowViewModel : INotifyPropertyChanged, IDisposable
{
    private bool _disposed = false;
    
    public void Dispose()
    {
        if (!_disposed)
        {
            // æ¸…ç†èµ„æº
            _memoryCleanupTimer?.Dispose();
            _disposed = true;
        }
    }
}
```

### 7. ç”¨æˆ·ä½“éªŒé—®é¢˜

#### é—®é¢˜ï¼šå¤„ç†è¿‡ç¨‹ä¸­æ— æ³•å–æ¶ˆ
```
ç”¨æˆ·æ— æ³•ä¸­é€”å–æ¶ˆæ‰¹é‡å¤„ç†
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ·»åŠ å–æ¶ˆåŠŸèƒ½
public class CancellableProcessor
{
    private CancellationTokenSource? _cancellationTokenSource;
    
    public async Task ProcessFolderAsync(string folderPath)
    {
        _cancellationTokenSource = new CancellationTokenSource();
        
        try
        {
            await ProcessFolderInternalAsync(folderPath, _cancellationTokenSource.Token);
        }
        catch (OperationCanceledException)
        {
            StatusMessage = "å¤„ç†å·²å–æ¶ˆ";
        }
    }
    
    public void Cancel()
    {
        _cancellationTokenSource?.Cancel();
    }
    
    private async Task ProcessFolderInternalAsync(string folderPath, CancellationToken cancellationToken)
    {
        var files = await ScanTxtFilesAsync(folderPath);
        TotalFiles = files.Length;
        
        foreach (var filePath in files)
        {
            cancellationToken.ThrowIfCancellationRequested();
            
            await ProcessSingleFileAsync(filePath, cancellationToken);
            ProcessedFiles++;
        }
    }
}

// UIä¸­çš„å–æ¶ˆæŒ‰é’®
<Button Content="{Binding IsProcessing, Converter={x:Static Converters.BoolToText}, ConverterParameter='å–æ¶ˆ|å¼€å§‹å¤„ç†'}" 
        Click="ToggleProcessing_Click"/>
```

#### é—®é¢˜ï¼šé”™è¯¯ä¿¡æ¯ä¸å¤Ÿè¯¦ç»†
```
ç”¨æˆ·æ— æ³•äº†è§£å…·ä½“çš„é”™è¯¯åŸå› 
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
public class DetailedErrorHandler
{
    public async Task ProcessFolderAsync(string folderPath)
    {
        try
        {
            await ProcessFolderInternalAsync(folderPath);
        }
        catch (DirectoryNotFoundException ex)
        {
            StatusMessage = $"æ–‡ä»¶å¤¹ä¸å­˜åœ¨: {folderPath}";
        }
        catch (UnauthorizedAccessException ex)
        {
            StatusMessage = $"æ²¡æœ‰è®¿é—®æƒé™: {folderPath}";
        }
        catch (IOException ex)
        {
            StatusMessage = $"æ–‡ä»¶æ“ä½œå¤±è´¥: {ex.Message}";
        }
        catch (OutOfMemoryException ex)
        {
            StatusMessage = "å†…å­˜ä¸è¶³ï¼Œè¯·å°è¯•å¤„ç†è¾ƒå°‘çš„æ–‡ä»¶";
        }
        catch (Exception ex)
        {
            StatusMessage = $"æœªçŸ¥é”™è¯¯: {ex.Message}";
        }
    }
    
    private void LogDetailedError(string filePath, Exception ex)
    {
        var errorInfo = new
        {
            FilePath = filePath,
            ErrorType = ex.GetType().Name,
            Message = ex.Message,
            StackTrace = ex.StackTrace,
            Timestamp = DateTime.Now
        };
        
        // è®°å½•åˆ°æ—¥å¿—æ–‡ä»¶
        File.AppendAllText("error.log", $"{errorInfo}\n");
    }
}
```

### 8. æ€»ç»“

æ‰¹é‡å¤„ç†åŠŸèƒ½å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡ˆï¼š

1. **æ–‡ä»¶å¤¹é€‰æ‹©**ï¼šæƒé™æ£€æŸ¥ã€è·¯å¾„éªŒè¯ã€å¹³å°å…¼å®¹æ€§
2. **æ–‡ä»¶æ‰«æ**ï¼šå†…å­˜ä¼˜åŒ–ã€æƒé™å¤„ç†ã€åˆ†æ‰¹å¤„ç†
3. **è¿›åº¦æ˜¾ç¤º**ï¼šUIçº¿ç¨‹æ›´æ–°ã€æ•°æ®ç»‘å®šã€è®¡ç®—å±æ€§
4. **æ•°æ®åˆå¹¶**ï¼šçº¿ç¨‹å®‰å…¨ã€é”®å€¼ç»Ÿä¸€ã€å†…å­˜ç®¡ç†
5. **å¼‚æ­¥å¤„ç†**ï¼šå–æ¶ˆæœºåˆ¶ã€å¼‚å¸¸å¤„ç†ã€UIå“åº”
6. **æ€§èƒ½ä¼˜åŒ–**ï¼šå¹¶è¡Œå¤„ç†ã€å†…å­˜æ¸…ç†ã€èµ„æºç®¡ç†
7. **ç”¨æˆ·ä½“éªŒ**ï¼šå–æ¶ˆåŠŸèƒ½ã€é”™è¯¯æç¤ºã€çŠ¶æ€åé¦ˆ

é€šè¿‡è§£å†³è¿™äº›é—®é¢˜ï¼Œå¯ä»¥æ„å»ºå‡ºç¨³å®šã€é«˜æ•ˆã€ç”¨æˆ·å‹å¥½çš„æ‰¹é‡å¤„ç†åŠŸèƒ½ï¼
