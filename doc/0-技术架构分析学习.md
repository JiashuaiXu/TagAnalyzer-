# .NET 10 + Avalonia UI æŠ€æœ¯æ¶æ„åˆ†æå­¦ä¹  (C# 14)

## ğŸ“š ç›®å½•

1. [é¡¹ç›®æ¶æ„è®¾è®¡](#é¡¹ç›®æ¶æ„è®¾è®¡)
2. [Avalonia UI æ¡†æ¶è¯¦è§£](#avalonia-ui-æ¡†æ¶è¯¦è§£)
3. [MVVM æ¨¡å¼å®ç°](#mvvm-æ¨¡å¼å®ç°)
4. [é¡¹ç›®åˆ›å»ºä¸é…ç½®](#é¡¹ç›®åˆ›å»ºä¸é…ç½®)
5. [ç¼–è¯‘ä¸å‘å¸ƒæµç¨‹](#ç¼–è¯‘ä¸å‘å¸ƒæµç¨‹)
6. [å¸¸è§é—®é¢˜ä¸è¸©å‘](#å¸¸è§é—®é¢˜ä¸è¸©å‘)
7. [æ€§èƒ½ä¼˜åŒ–å»ºè®®](#æ€§èƒ½ä¼˜åŒ–å»ºè®®)
8. [æ‰©å±•åŠŸèƒ½æ€è·¯](#æ‰©å±•åŠŸèƒ½æ€è·¯)
9. [C# 14 æ–°ç‰¹æ€§ä¸è¯­æ³•ç³–](#c-14-æ–°ç‰¹æ€§ä¸è¯­æ³•ç³–)
10. [æ‰¹é‡å¤„ç†åŠŸèƒ½æ¶æ„è®¾è®¡](#æ‰¹é‡å¤„ç†åŠŸèƒ½æ¶æ„è®¾è®¡)

---

## ğŸ—ï¸ é¡¹ç›®æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Tag Analyzer åº”ç”¨æ¶æ„                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Presentation Layer (è¡¨ç¤ºå±‚)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   MainWindow    â”‚  â”‚   App.axaml     â”‚  â”‚   Program    â”‚ â”‚
â”‚  â”‚   (UIç•Œé¢)       â”‚  â”‚   (åº”ç”¨å®šä¹‰)     â”‚  â”‚   (å…¥å£ç‚¹)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Business Logic Layer (ä¸šåŠ¡é€»è¾‘å±‚)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ MainWindowVM    â”‚  â”‚   TagInfoVM     â”‚                  â”‚
â”‚  â”‚ (ä¸»è§†å›¾æ¨¡å‹)     â”‚  â”‚  (æ•°æ®è§†å›¾æ¨¡å‹)  â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Access Layer (æ•°æ®è®¿é—®å±‚)                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚   TextParser    â”‚  â”‚   TagInfo       â”‚                  â”‚
â”‚  â”‚   (æ–‡æœ¬è§£æ)     â”‚  â”‚   (æ•°æ®æ¨¡å‹)    â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  External Libraries (å¤–éƒ¨åº“)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚   Avalonia UI   â”‚  â”‚   CsvHelper     â”‚                  â”‚
â”‚  â”‚   (UIæ¡†æ¶)       â”‚  â”‚   (CSVå¤„ç†)     â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¶æ„è®¾è®¡åŸåˆ™

1. **åˆ†å±‚æ¶æ„ (Layered Architecture)**
   - è¡¨ç¤ºå±‚ï¼šè´Ÿè´£ç”¨æˆ·ç•Œé¢å’Œç”¨æˆ·äº¤äº’
   - ä¸šåŠ¡é€»è¾‘å±‚ï¼šå¤„ç†åº”ç”¨çš„æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
   - æ•°æ®è®¿é—®å±‚ï¼šå¤„ç†æ•°æ®è§£æå’Œæ¨¡å‹å®šä¹‰

2. **å…³æ³¨ç‚¹åˆ†ç¦» (Separation of Concerns)**
   - UIé€»è¾‘ä¸ä¸šåŠ¡é€»è¾‘åˆ†ç¦»
   - æ•°æ®æ¨¡å‹ä¸è§†å›¾æ¨¡å‹åˆ†ç¦»
   - è§£æé€»è¾‘ä¸æ˜¾ç¤ºé€»è¾‘åˆ†ç¦»

3. **ä¾èµ–æ³¨å…¥ (Dependency Injection)**
   - é€šè¿‡æ„é€ å‡½æ•°æ³¨å…¥ä¾èµ–
   - ä¾¿äºå•å…ƒæµ‹è¯•å’Œæ¨¡å—æ›¿æ¢

---

## ğŸ¨ Avalonia UI æ¡†æ¶è¯¦è§£

### ä»€ä¹ˆæ˜¯ Avalonia UIï¼Ÿ

Avalonia UI æ˜¯ä¸€ä¸ªè·¨å¹³å°çš„ .NET UI æ¡†æ¶ï¼Œç±»ä¼¼äº WPFï¼Œä½†æ”¯æŒ Windowsã€Linuxã€macOS ç­‰å¤šä¸ªå¹³å°ã€‚

### æ ¸å¿ƒæ¦‚å¿µ

#### 1. XAML è¯­æ³•

```xml
<!-- åŸºæœ¬æ§ä»¶å®šä¹‰ -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="TagAnalyzer.MainWindow"
        Title="æ ‡ç­¾åˆ†æå·¥å…·">
    
    <!-- å¸ƒå±€å®¹å™¨ -->
    <Grid RowDefinitions="Auto,*,Auto">
        <!-- å†…å®¹ -->
    </Grid>
</Window>
```

#### 2. æ•°æ®ç»‘å®š

```xml
<!-- å•å‘ç»‘å®š -->
<TextBlock Text="{Binding StatusMessage}" />

<!-- åŒå‘ç»‘å®š -->
<TextBox Text="{Binding UserInput}" />

<!-- å‘½ä»¤ç»‘å®š -->
<Button Command="{Binding ProcessCommand}" />
```

#### 3. æ ·å¼å’Œä¸»é¢˜

```xml
<!-- å†…è”æ ·å¼ -->
<Button Classes="accent" />

<!-- èµ„æºæ ·å¼ -->
<Application.Styles>
    <FluentTheme />
</Application.Styles>
```

### å¸¸ç”¨æ§ä»¶

| æ§ä»¶ | ç”¨é€” | ç¤ºä¾‹ |
|------|------|------|
| `Window` | ä¸»çª—å£ | `<Window Title="åº”ç”¨">` |
| `Grid` | ç½‘æ ¼å¸ƒå±€ | `<Grid RowDefinitions="Auto,*">` |
| `StackPanel` | å †å å¸ƒå±€ | `<StackPanel Orientation="Horizontal">` |
| `Button` | æŒ‰é’® | `<Button Content="ç¡®å®š" Click="OnClick">` |
| `TextBox` | æ–‡æœ¬è¾“å…¥ | `<TextBox Text="{Binding Input}">` |
| `ListBox` | åˆ—è¡¨æ˜¾ç¤º | `<ListBox ItemsSource="{Binding Items}">` |
| `DataGrid` | æ•°æ®è¡¨æ ¼ | `<DataGrid ItemsSource="{Binding Data}">` |

### å¸ƒå±€ç³»ç»Ÿ

#### Grid å¸ƒå±€
```xml
<Grid>
    <Grid.RowDefinitions>
        <RowDefinition Height="Auto"/>  <!-- è‡ªé€‚åº”é«˜åº¦ -->
        <RowDefinition Height="*"/>      <!-- å‰©ä½™ç©ºé—´ -->
        <RowDefinition Height="100"/>    <!-- å›ºå®šé«˜åº¦ -->
    </Grid.RowDefinitions>
    
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="Auto"/>
        <ColumnDefinition Width="*"/>
    </Grid.ColumnDefinitions>
    
    <Button Grid.Row="0" Grid.Column="0" Content="æŒ‰é’®"/>
</Grid>
```

#### StackPanel å¸ƒå±€
```xml
<StackPanel Orientation="Vertical" Spacing="10">
    <Button Content="æŒ‰é’®1"/>
    <Button Content="æŒ‰é’®2"/>
</StackPanel>
```

---

## ğŸ”„ MVVM æ¨¡å¼å®ç°

### MVVM æ¶æ„æ¨¡å¼

MVVM (Model-View-ViewModel) æ˜¯ä¸€ç§æ¶æ„æ¨¡å¼ï¼Œå°†åº”ç”¨ç¨‹åºåˆ†ä¸ºä¸‰ä¸ªä¸»è¦éƒ¨åˆ†ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    View     â”‚â—„â”€â”€â–ºâ”‚  ViewModel   â”‚â—„â”€â”€â–ºâ”‚    Model    â”‚
â”‚   (è§†å›¾)     â”‚    â”‚  (è§†å›¾æ¨¡å‹)   â”‚    â”‚   (æ¨¡å‹)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1. Model (æ¨¡å‹å±‚)

```csharp
// æ•°æ®æ¨¡å‹
public class TagInfo
{
    public string Tag { get; set; } = string.Empty;
    public int Count { get; set; }
    public List<string> SourceIds { get; set; } = new();
}

// ä¸šåŠ¡é€»è¾‘
public class TextParser
{
    public static List<TagInfo> ParseText(string text)
    {
        // è§£æé€»è¾‘
    }
}
```

### 2. ViewModel (è§†å›¾æ¨¡å‹å±‚)

```csharp
public class MainWindowViewModel : INotifyPropertyChanged
{
    private string _statusMessage = string.Empty;
    
    public string StatusMessage
    {
        get => _statusMessage;
        set
        {
            _statusMessage = value;
            OnPropertyChanged(); // é€šçŸ¥UIæ›´æ–°
        }
    }
    
    public event PropertyChangedEventHandler? PropertyChanged;
    
    protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

### 3. View (è§†å›¾å±‚)

```xml
<Window x:Class="TagAnalyzer.MainWindow"
        x:DataType="vm:MainWindowViewModel">
    <Design.DataContext>
        <vm:MainWindowViewModel/>
    </Design.DataContext>
    
    <TextBlock Text="{Binding StatusMessage}"/>
</Window>
```

### MVVM çš„ä¼˜åŠ¿

1. **å¯æµ‹è¯•æ€§**ï¼šViewModel å¯ä»¥ç‹¬ç«‹è¿›è¡Œå•å…ƒæµ‹è¯•
2. **å¯ç»´æŠ¤æ€§**ï¼šUI å’Œä¸šåŠ¡é€»è¾‘åˆ†ç¦»
3. **å¯é‡ç”¨æ€§**ï¼šViewModel å¯ä»¥åœ¨ä¸åŒ View ä¸­é‡ç”¨
4. **æ•°æ®ç»‘å®š**ï¼šè‡ªåŠ¨åŒæ­¥ UI å’Œæ•°æ®

---

## ğŸš€ é¡¹ç›®åˆ›å»ºä¸é…ç½®

### 1. åˆ›å»ºæ–°é¡¹ç›®

```bash
# åˆ›å»º Avalonia é¡¹ç›®
dotnet new avalonia.mvvm -n TagAnalyzer
cd TagAnalyzer
```

### 2. é¡¹ç›®æ–‡ä»¶é…ç½® (.csproj)

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <BuiltInComInteropSupport>true</BuiltInComInteropSupport>
    <ApplicationManifest>app.manifest</ApplicationManifest>
    <AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>
    
    <!-- é¡¹ç›®å…ƒæ•°æ® -->
    <AssemblyTitle>Tag Analyzer</AssemblyTitle>
    <AssemblyDescription>æ–‡æœ¬æ ‡ç­¾åˆ†æå·¥å…·</AssemblyDescription>
    <AssemblyCompany>jiashuai_xu@qq.com</AssemblyCompany>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </PropertyGroup>

  <ItemGroup>
    <!-- Avalonia UI æ ¸å¿ƒåŒ… -->
    <PackageReference Include="Avalonia" Version="11.0.10" />
    <PackageReference Include="Avalonia.Desktop" Version="11.0.10" />
    <PackageReference Include="Avalonia.Themes.Fluent" Version="11.0.10" />
    <PackageReference Include="Avalonia.Fonts.Inter" Version="11.0.10" />
    <PackageReference Include="Avalonia.ReactiveUI" Version="11.0.10" />
    
    <!-- ç¬¬ä¸‰æ–¹åº“ -->
    <PackageReference Include="CsvHelper" Version="30.0.1" />
  </ItemGroup>
</Project>
```

### 3. åº”ç”¨ç¨‹åºå…¥å£ç‚¹

```csharp
// Program.cs
using Avalonia;

namespace TagAnalyzer;

internal class Program
{
    [STAThread]
    public static void Main(string[] args) => BuildAvaloniaApp()
        .StartWithClassicDesktopLifetime(args);

    public static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .WithInterFont()
            .LogToTrace();
}
```

### 4. åº”ç”¨ç¨‹åºå®šä¹‰

```csharp
// App.axaml.cs
public partial class App : Application
{
    public override void Initialize()
    {
        AvaloniaXamlLoader.Load(this);
    }

    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            desktop.MainWindow = new MainWindow();
        }
        base.OnFrameworkInitializationCompleted();
    }
}
```

---

## ğŸ”¨ ç¼–è¯‘ä¸å‘å¸ƒæµç¨‹

### 1. å¼€å‘é˜¶æ®µç¼–è¯‘

```bash
# è¿˜åŸä¾èµ–åŒ…
dotnet restore

# ç¼–è¯‘é¡¹ç›®
dotnet build

# è¿è¡Œé¡¹ç›®
dotnet run
```

### 2. å‘å¸ƒé…ç½®

#### å•æ–‡ä»¶å‘å¸ƒ
```bash
dotnet publish --configuration Release \
               --runtime win-x64 \
               --self-contained true \
               --output ./publish \
               --property:PublishSingleFile=true \
               --property:IncludeNativeLibrariesForSelfExtract=true
```

#### å‚æ•°è¯´æ˜
- `--configuration Release`ï¼šå‘å¸ƒç‰ˆæœ¬
- `--runtime win-x64`ï¼šç›®æ ‡è¿è¡Œæ—¶
- `--self-contained true`ï¼šåŒ…å«è¿è¡Œæ—¶
- `--property:PublishSingleFile=true`ï¼šå•æ–‡ä»¶å‘å¸ƒ
- `--property:IncludeNativeLibrariesForSelfExtract=true`ï¼šåŒ…å«æœ¬åœ°åº“

### 3. å‘å¸ƒè„šæœ¬

```powershell
# publish.ps1
Write-Host "=== å‘å¸ƒè„šæœ¬ ===" -ForegroundColor Green

# æ£€æŸ¥ .NET SDK
$dotnetVersion = dotnet --version
if ($LASTEXITCODE -ne 0) {
    Write-Host "é”™è¯¯ï¼šæœªæ‰¾åˆ° .NET SDK" -ForegroundColor Red
    exit 1
}

# æ¸…ç†æ„å»º
dotnet clean --configuration Release

# è¿˜åŸåŒ…
dotnet restore

# å‘å¸ƒ
dotnet publish --configuration Release \
               --runtime win-x64 \
               --self-contained true \
               --output ./publish \
               --property:PublishSingleFile=true \
               --property:IncludeNativeLibrariesForSelfExtract=true

Write-Host "å‘å¸ƒå®Œæˆï¼" -ForegroundColor Green
```

### 4. æ–‡ä»¶å¤§å°ä¼˜åŒ–

| å‘å¸ƒæ–¹å¼ | æ–‡ä»¶å¤§å° | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|----------|----------|------|------|
| æ¡†æ¶ä¾èµ– | ~10MB | æ–‡ä»¶å° | éœ€è¦å®‰è£… .NET Runtime |
| è‡ªåŒ…å« | ~90MB | æ— éœ€å®‰è£…è¿è¡Œæ—¶ | æ–‡ä»¶è¾ƒå¤§ |
| å•æ–‡ä»¶ | ~90MB | åˆ†å‘ç®€å• | å¯åŠ¨ç¨æ…¢ |

---

## âš ï¸ å¸¸è§é—®é¢˜ä¸è¸©å‘

### 1. ç¼–è¯‘é”™è¯¯

#### é—®é¢˜ï¼šDataGrid æ— æ³•è§£æ
```
error AXN0002: Unable to resolve type DataGrid
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- æ·»åŠ å‘½åç©ºé—´ -->
<Window xmlns:avalonia="using:Avalonia.Controls">
    <avalonia:DataGrid ItemsSource="{Binding Items}"/>
</Window>
```

#### é—®é¢˜ï¼šè½¬æ¢å™¨æ— æ³•æ‰¾åˆ°
```
error AVLN:0004: Unable to resolve NotEqualTo
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```xml
<!-- ç®€åŒ–ç»‘å®šï¼Œé¿å…å¤æ‚è½¬æ¢å™¨ -->
<Button IsEnabled="{Binding HasData}"/>
```

### 2. è¿è¡Œæ—¶é”™è¯¯

#### é—®é¢˜ï¼šInitializeComponent ä¸å­˜åœ¨
```
error CS0103: The name 'InitializeComponent' does not not exist
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// ç¡®ä¿ XAML æ–‡ä»¶å­˜åœ¨ä¸”æ­£ç¡®
// æ£€æŸ¥å‘½åç©ºé—´æ˜¯å¦æ­£ç¡®
```

#### é—®é¢˜ï¼šæ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†ä¸å·¥ä½œ
```csharp
// é”™è¯¯ï¼šç›´æ¥ä½¿ç”¨ OpenFileDialog
var dialog = new OpenFileDialog();

// æ­£ç¡®ï¼šä½¿ç”¨ StorageProvider
var files = await StorageProvider.OpenFilePickerAsync(options);
```

### 3. æ•°æ®ç»‘å®šé—®é¢˜

#### é—®é¢˜ï¼šç»‘å®šä¸æ›´æ–°
```csharp
// é”™è¯¯ï¼šæ²¡æœ‰å®ç° INotifyPropertyChanged
public string Status { get; set; }

// æ­£ç¡®ï¼šå®ç°å±æ€§å˜æ›´é€šçŸ¥
public string Status
{
    get => _status;
    set
    {
        _status = value;
        OnPropertyChanged();
    }
}
```

#### é—®é¢˜ï¼šé›†åˆç»‘å®šä¸å·¥ä½œ
```csharp
// é”™è¯¯ï¼šä½¿ç”¨ List<T>
public List<TagInfo> Items { get; set; }

// æ­£ç¡®ï¼šä½¿ç”¨ ObservableCollection<T>
public ObservableCollection<TagInfo> Items { get; set; }
```

### 4. å‘å¸ƒé—®é¢˜

#### é—®é¢˜ï¼šå‘å¸ƒåæ— æ³•è¿è¡Œ
- æ£€æŸ¥ç›®æ ‡è¿è¡Œæ—¶æ˜¯å¦æ­£ç¡®
- ç¡®ä¿æ‰€æœ‰ä¾èµ–éƒ½å·²åŒ…å«
- æ£€æŸ¥åº”ç”¨ç¨‹åºæ¸…å•æ–‡ä»¶

#### é—®é¢˜ï¼šæ–‡ä»¶è¿‡å¤§
- ä½¿ç”¨æ¡†æ¶ä¾èµ–å‘å¸ƒ
- æ’é™¤ä¸å¿…è¦çš„èµ„æºæ–‡ä»¶
- ä½¿ç”¨ ILTrim ä¼˜åŒ–

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. æ•°æ®ç»‘å®šä¼˜åŒ–

```csharp
// ä½¿ç”¨ç¼–è¯‘æ—¶ç»‘å®š
<Window x:DataType="vm:MainWindowViewModel">
    <TextBlock Text="{Binding StatusMessage}"/>
</Window>
```

### 2. é›†åˆæ“ä½œä¼˜åŒ–

```csharp
// ä½¿ç”¨ ObservableCollection çš„æ‰¹é‡æ“ä½œ
public void UpdateItems(List<TagInfo> newItems)
{
    Items.Clear();
    foreach (var item in newItems)
    {
        Items.Add(item);
    }
}
```

### 3. å¼‚æ­¥æ“ä½œ

```csharp
// æ–‡ä»¶æ“ä½œä½¿ç”¨å¼‚æ­¥
public async Task ProcessFileAsync(string filePath)
{
    var text = await File.ReadAllTextAsync(filePath);
    ProcessText(text);
}
```

### 4. å†…å­˜ç®¡ç†

```csharp
// åŠæ—¶é‡Šæ”¾èµ„æº
public void Dispose()
{
    _tagInfos?.Clear();
    _tagInfos = null;
}
```

---

## ğŸ”§ æ‰©å±•åŠŸèƒ½æ€è·¯

### 1. åŠŸèƒ½æ‰©å±•

- **å¤šæ–‡ä»¶æ‰¹é‡å¤„ç†**ï¼šæ”¯æŒåŒæ—¶å¤„ç†å¤šä¸ªæ–‡ä»¶
- **æ ‡ç­¾è¿‡æ»¤**ï¼šæŒ‰æ¡ä»¶è¿‡æ»¤æ˜¾ç¤ºçš„æ ‡ç­¾
- **æ•°æ®å¯¼å‡º**ï¼šæ”¯æŒ Excelã€JSON ç­‰æ ¼å¼
- **å†å²è®°å½•**ï¼šä¿å­˜å¤„ç†å†å²

### 2. UI å¢å¼º

- **ä¸»é¢˜åˆ‡æ¢**ï¼šæ”¯æŒæ·±è‰²/æµ…è‰²ä¸»é¢˜
- **å¤šè¯­è¨€æ”¯æŒ**ï¼šå›½é™…åŒ–æ”¯æŒ
- **è‡ªå®šä¹‰å¸ƒå±€**ï¼šç”¨æˆ·å¯è°ƒæ•´ç•Œé¢å¸ƒå±€
- **è¿›åº¦æ˜¾ç¤º**ï¼šå¤§æ–‡ä»¶å¤„ç†æ—¶æ˜¾ç¤ºè¿›åº¦

### 3. æ€§èƒ½ä¼˜åŒ–

- **è™šæ‹ŸåŒ–åˆ—è¡¨**ï¼šå¤§é‡æ•°æ®æ—¶ä½¿ç”¨è™šæ‹ŸåŒ–
- **ç¼“å­˜æœºåˆ¶**ï¼šç¼“å­˜è§£æç»“æœ
- **åå°å¤„ç†**ï¼šå¤§æ–‡ä»¶åœ¨åå°çº¿ç¨‹å¤„ç†
- **å¢é‡æ›´æ–°**ï¼šåªæ›´æ–°å˜åŒ–çš„æ•°æ®

### 4. æ’ä»¶ç³»ç»Ÿ

```csharp
// æ’ä»¶æ¥å£
public interface ITextProcessor
{
    string Name { get; }
    List<TagInfo> Process(string text);
}

// æ’ä»¶ç®¡ç†å™¨
public class PluginManager
{
    private List<ITextProcessor> _processors = new();
    
    public void RegisterProcessor(ITextProcessor processor)
    {
        _processors.Add(processor);
    }
}
```

---

## ğŸ“– å­¦ä¹ èµ„æº

### å®˜æ–¹æ–‡æ¡£
- [Avalonia UI å®˜æ–¹æ–‡æ¡£](https://docs.avaloniaui.net/)
- [.NET 8 å®˜æ–¹æ–‡æ¡£](https://docs.microsoft.com/en-us/dotnet/)
- [MVVM æ¨¡å¼æŒ‡å—](https://docs.microsoft.com/en-us/dotnet/architecture/maui/mvvm)

### æ¨èä¹¦ç±
- ã€ŠPro WPF and Silverlight MVVMã€‹
- ã€Š.NET Core in Actionã€‹
- ã€ŠClean Architectureã€‹

### åœ¨çº¿èµ„æº
- [Avalonia UI GitHub](https://github.com/AvaloniaUI/Avalonia)
- [.NET Community](https://dotnet.microsoft.com/en-us/community)
- [Stack Overflow](https://stackoverflow.com/questions/tagged/avalonia)

---

## ğŸ¯ æ€»ç»“

é€šè¿‡è¿™ä¸ªé¡¹ç›®ï¼Œæˆ‘ä»¬å­¦ä¹ äº†ï¼š

1. **Avalonia UI æ¡†æ¶**ï¼šè·¨å¹³å° UI å¼€å‘
2. **MVVM æ¨¡å¼**ï¼šæ¶æ„è®¾è®¡å’Œæ•°æ®ç»‘å®š
3. **.NET 8 ç‰¹æ€§**ï¼šç°ä»£ C# å¼€å‘
4. **é¡¹ç›®å‘å¸ƒ**ï¼šå•æ–‡ä»¶å‘å¸ƒå’Œéƒ¨ç½²
5. **é—®é¢˜è§£å†³**ï¼šå¸¸è§é”™è¯¯å’Œè§£å†³æ–¹æ¡ˆ

è¿™ä¸ªæŠ€æœ¯æ ˆéå¸¸é€‚åˆå¼€å‘è·¨å¹³å°çš„æ¡Œé¢åº”ç”¨ç¨‹åºï¼Œå…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š
- è·¨å¹³å°æ”¯æŒ
- ç°ä»£åŒ– UI
- å¼ºå¤§çš„æ•°æ®ç»‘å®š
- ä¸°å¯Œçš„ç”Ÿæ€ç³»ç»Ÿ
- è‰¯å¥½çš„æ€§èƒ½

ç»§ç»­æ·±å…¥å­¦ä¹ è¿™äº›æŠ€æœ¯ï¼Œå¯ä»¥å¼€å‘å‡ºæ›´åŠ å¤æ‚å’ŒåŠŸèƒ½ä¸°å¯Œçš„åº”ç”¨ç¨‹åºï¼

---

## ğŸš€ C# 14 æ–°ç‰¹æ€§ä¸è¯­æ³•ç³–

### 1. ä¸»è¦è¡¨è¾¾å¼ (Primary Expressions)

#### é›†åˆè¡¨è¾¾å¼ (Collection Expressions)
```csharp
// C# 14 æ–°è¯­æ³• - é›†åˆè¡¨è¾¾å¼
public class TagAnalyzer
{
    // åˆ—è¡¨åˆå§‹åŒ–
    private readonly List<string> _supportedExtensions = ["txt", "csv", "json"];
    
    // æ•°ç»„åˆå§‹åŒ–
    private readonly string[] _fileTypes = ["æ–‡æœ¬æ–‡ä»¶", "CSVæ–‡ä»¶", "JSONæ–‡ä»¶"];
    
    // å­—å…¸åˆå§‹åŒ–
    private readonly Dictionary<string, string> _mimeTypes = new()
    {
        ["txt"] = "text/plain",
        ["csv"] = "text/csv",
        ["json"] = "application/json"
    };
    
    // åœ¨æ–¹æ³•ä¸­ä½¿ç”¨
    public IEnumerable<string> GetFileExtensions()
    {
        return ["txt", "csv", "json", "xml"]; // ç›´æ¥è¿”å›é›†åˆ
    }
}
```

#### å­—ç¬¦ä¸²æ’å€¼å¢å¼º
```csharp
// C# 14 å­—ç¬¦ä¸²æ’å€¼å¢å¼º
public class StatusReporter
{
    public string GetStatusMessage(int processed, int total, TimeSpan elapsed)
    {
        // æ”¯æŒå¤æ‚è¡¨è¾¾å¼å’Œæ ¼å¼åŒ–
        return $"å¤„ç†è¿›åº¦: {processed}/{total} ({processed * 100.0 / total:F1}%) - è€—æ—¶: {elapsed:mm\\:ss}";
    }
    
    // åŸå§‹å­—ç¬¦ä¸²å­—é¢é‡ (C# 11+)
    public string GetLogMessage() => """
        å¤„ç†å®Œæˆï¼
        æ–‡ä»¶: {0}
        æ ‡ç­¾: {1} ä¸ª
        è€—æ—¶: {2}
        """;
}
```

### 2. æ¨¡å¼åŒ¹é…å¢å¼º

#### åˆ—è¡¨æ¨¡å¼ (List Patterns)
```csharp
// C# 14 åˆ—è¡¨æ¨¡å¼åŒ¹é…
public class TextParser
{
    public ParseResult ParseText(string text)
    {
        var lines = text.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        
        return lines switch
        {
            [] => new ParseResult { Status = "ç©ºæ–‡ä»¶" },
            [var singleLine] when singleLine.StartsWith("M35_") => 
                ProcessSingleLine(singleLine),
            [var first, .. var rest] when first.StartsWith("M35_") => 
                ProcessMultipleLines([first, .. rest]),
            _ => new ParseResult { Status = "æ ¼å¼ä¸æ”¯æŒ" }
        };
    }
    
    private ParseResult ProcessSingleLine(string line)
    {
        // å¤„ç†å•è¡Œ
        return new ParseResult();
    }
    
    private ParseResult ProcessMultipleLines(string[] lines)
    {
        // å¤„ç†å¤šè¡Œ
        return new ParseResult();
    }
}
```

#### åˆ‡ç‰‡æ¨¡å¼ (Slice Patterns)
```csharp
// C# 14 åˆ‡ç‰‡æ¨¡å¼
public class DataProcessor
{
    public string ProcessData(string[] data)
    {
        return data switch
        {
            [var first, .. var middle, var last] => 
                $"å¼€å§‹: {first}, ä¸­é—´: {middle.Length} é¡¹, ç»“æŸ: {last}",
            [var single] => $"å•ä¸€é¡¹: {single}",
            [] => "ç©ºæ•°æ®",
            _ => "æœªçŸ¥æ ¼å¼"
        };
    }
}
```

### 3. ç±»å‹ç³»ç»Ÿå¢å¼º

#### å¿…éœ€æˆå‘˜ (Required Members)
```csharp
// C# 14 å¿…éœ€æˆå‘˜
public class TagInfo
{
    public required string Tag { get; set; }  // å¿…éœ€å±æ€§
    public required int Count { get; set; }    // å¿…éœ€å±æ€§
    public List<string> SourceIds { get; set; } = []; // å¯é€‰å±æ€§ï¼Œä½¿ç”¨é›†åˆè¡¨è¾¾å¼åˆå§‹åŒ–
    
    // å¿…éœ€æ„é€ å‡½æ•°å‚æ•°
    public TagInfo(string tag, int count)
    {
        Tag = tag;
        Count = count;
    }
}

// ä½¿ç”¨å¿…éœ€æˆå‘˜
var tagInfo = new TagInfo("æŠ½æ³£", 5)
{
    SourceIds = ["M35_230001", "M35_230002"] // å¿…éœ€æˆå‘˜å·²é€šè¿‡æ„é€ å‡½æ•°è®¾ç½®
};
```

#### æ–‡ä»¶æœ¬åœ°ç±»å‹ (File-local Types)
```csharp
// File1.cs
file class InternalHelper
{
    public static string ProcessData(string input) => input.ToUpper();
}

// File2.cs
file class InternalHelper
{
    public static string ProcessData(string input) => input.ToLower();
}

// æ¯ä¸ªæ–‡ä»¶éƒ½æœ‰è‡ªå·±çš„ InternalHelperï¼Œä¸ä¼šå†²çª
```

### 4. å¼‚æ­¥å’Œæ€§èƒ½å¢å¼º

#### å¼‚æ­¥æµ (Async Streams) å¢å¼º
```csharp
// C# 14 å¼‚æ­¥æµå¢å¼º
public class FileProcessor
{
    public async IAsyncEnumerable<string> ProcessFilesAsync(IEnumerable<string> filePaths)
    {
        await foreach (var filePath in filePaths.ToAsyncEnumerable())
        {
            var content = await File.ReadAllTextAsync(filePath);
            yield return ProcessContent(content);
        }
    }
    
    // ä½¿ç”¨ ConfigureAwait(false) ä¼˜åŒ–
    public async Task<ParseResult> ParseFileAsync(string filePath)
    {
        using var stream = File.OpenRead(filePath);
        using var reader = new StreamReader(stream);
        var content = await reader.ReadToEndAsync().ConfigureAwait(false);
        
        return await Task.Run(() => TextParser.ParseText(content)).ConfigureAwait(false);
    }
}
```

#### é™æ€æŠ½è±¡æˆå‘˜ (Static Abstract Members)
```csharp
// C# 14 é™æ€æŠ½è±¡æˆå‘˜
public interface IDataProcessor<T>
{
    static abstract T Process(string input);
    static abstract bool Validate(T data);
}

public class TagProcessor : IDataProcessor<TagInfo>
{
    public static TagInfo Process(string input)
    {
        // å¤„ç†é€»è¾‘
        return new TagInfo("", 0);
    }
    
    public static bool Validate(TagInfo data)
    {
        return !string.IsNullOrEmpty(data.Tag) && data.Count > 0;
    }
}

// ä½¿ç”¨é™æ€æŠ½è±¡æˆå‘˜
public class GenericProcessor<T> where T : IDataProcessor<T>
{
    public T ProcessData(string input)
    {
        var result = T.Process(input);
        if (!T.Validate(result))
            throw new InvalidOperationException("æ•°æ®éªŒè¯å¤±è´¥");
        return result;
    }
}
```

### 5. ç©ºå€¼å¤„ç†å¢å¼º

#### ç©ºåˆå¹¶èµ‹å€¼ (Null Coalescing Assignment)
```csharp
// C# 14 ç©ºåˆå¹¶èµ‹å€¼å¢å¼º
public class ViewModel
{
    private ObservableCollection<TagInfo>? _tagInfos;
    
    public ObservableCollection<TagInfo> TagInfos
    {
        get
        {
            _tagInfos ??= []; // ä½¿ç”¨é›†åˆè¡¨è¾¾å¼åˆå§‹åŒ–
            return _tagInfos;
        }
        set => _tagInfos = value;
    }
    
    // ç©ºæ¡ä»¶é“¾å¼è°ƒç”¨
    public void UpdateStatus()
    {
        var count = TagInfos?.Count ?? 0;
        StatusMessage = $"å…±æ‰¾åˆ° {count} ä¸ªæ ‡ç­¾";
    }
}
```

#### ç©ºå€¼ä¼ æ’­ (Null Propagation) å¢å¼º
```csharp
// C# 14 ç©ºå€¼ä¼ æ’­å¢å¼º
public class DataService
{
    public string? GetFileName(string? filePath)
    {
        return filePath?.Split('\\', '/').LastOrDefault();
    }
    
    public int GetFileSize(string? filePath)
    {
        return new FileInfo(filePath ?? "").Length;
    }
}
```

### 6. æ¨¡å¼åŒ¹é…åœ¨ MVVM ä¸­çš„åº”ç”¨

#### ViewModel ä¸­çš„æ¨¡å¼åŒ¹é…
```csharp
// C# 14 åœ¨ ViewModel ä¸­ä½¿ç”¨æ¨¡å¼åŒ¹é…
public class MainWindowViewModel : BaseViewModel
{
    public void HandleCommand(object? parameter)
    {
        switch (parameter)
        {
            case string filePath when !string.IsNullOrEmpty(filePath):
                ProcessFileAsync(filePath);
                break;
            case TagInfo tagInfo:
                SelectTag(tagInfo);
                break;
            case { } obj when obj.GetType().Name.Contains("Export"):
                ExportData();
                break;
            case null:
                StatusMessage = "å‚æ•°ä¸ºç©º";
                break;
        }
    }
    
    // ä½¿ç”¨æ¨¡å¼åŒ¹é…è¿›è¡Œæ•°æ®éªŒè¯
    public bool ValidateInput(object? input)
    {
        return input switch
        {
            string s when s.Length > 0 => true,
            int i when i > 0 => true,
            TagInfo t when !string.IsNullOrEmpty(t.Tag) => true,
            _ => false
        };
    }
}
```

### 7. æ€§èƒ½ä¼˜åŒ–è¯­æ³•ç³–

#### Span<T> å’Œ Memory<T> ä½¿ç”¨
```csharp
// C# 14 é«˜æ€§èƒ½å­—ç¬¦ä¸²å¤„ç†
public class HighPerformanceParser
{
    public ReadOnlySpan<char> ExtractTag(ReadOnlySpan<char> line)
    {
        var startIndex = line.IndexOf("ã€");
        if (startIndex == -1) return ReadOnlySpan<char>.Empty;
        
        var endIndex = line.IndexOf("ã€‘", startIndex);
        if (endIndex == -1) return ReadOnlySpan<char>.Empty;
        
        return line.Slice(startIndex + 1, endIndex - startIndex - 1);
    }
    
    // ä½¿ç”¨ Memory<T> è¿›è¡Œå¼‚æ­¥å¤„ç†
    public async Task<Memory<char>> ProcessTextAsync(Memory<char> text)
    {
        await Task.Delay(100); // æ¨¡æ‹Ÿå¼‚æ­¥å¤„ç†
        return text;
    }
}
```

#### è®°å½•ç±»å‹ (Records) å¢å¼º
```csharp
// C# 14 è®°å½•ç±»å‹å¢å¼º
public record ParseResult(
    List<TagInfo> TagInfos,
    int ProcessedLines,
    TimeSpan ProcessingTime,
    List<string> Errors = []
)
{
    // è®¡ç®—å±æ€§
    public bool HasErrors => Errors.Count > 0;
    public int TotalTags => TagInfos.Count;
    
    // æ–¹æ³•
    public string GetSummary() => 
        $"å¤„ç†å®Œæˆ: {TotalTags} ä¸ªæ ‡ç­¾, {ProcessedLines} è¡Œ, è€—æ—¶ {ProcessingTime:mm\\:ss}";
}

// ä½¿ç”¨è®°å½•ç±»å‹
var result = new ParseResult(
    TagInfos: [new TagInfo("æŠ½æ³£", 2), new TagInfo("å¹æ°”", 1)],
    ProcessedLines: 10,
    ProcessingTime: TimeSpan.FromSeconds(1.5)
);
```

### 8. ç°ä»£ C# åœ¨é¡¹ç›®ä¸­çš„åº”ç”¨

#### é¡¹ç›®æ–‡ä»¶é…ç½® (.csproj)
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <LangVersion>14</LangVersion>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <BuiltInComInteropSupport>true</BuiltInComInteropSupport>
    <ApplicationManifest>app.manifest</ApplicationManifest>
    <AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>
    
    <!-- C# 14 ç‰¹æ€§ -->
    <EnablePreviewFeatures>true</EnablePreviewFeatures>
    <AnalysisLevel>latest</AnalysisLevel>
  </PropertyGroup>
</Project>
```

#### ç°ä»£å¼‚æ­¥æ¨¡å¼
```csharp
// C# 14 ç°ä»£å¼‚æ­¥æ¨¡å¼
public class ModernFileService
{
    public async Task<ParseResult> ProcessFileAsync(string filePath, CancellationToken cancellationToken = default)
    {
        await using var file = File.OpenRead(filePath);
        using var reader = new StreamReader(file);
        
        var content = await reader.ReadToEndAsync(cancellationToken);
        
        return await Task.Run(() => TextParser.ParseText(content), cancellationToken);
    }
    
    // ä½¿ç”¨ IAsyncEnumerable
    public async IAsyncEnumerable<ParseResult> ProcessFilesAsync(
        IEnumerable<string> filePaths,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        foreach (var filePath in filePaths)
        {
            cancellationToken.ThrowIfCancellationRequested();
            yield return await ProcessFileAsync(filePath, cancellationToken);
        }
    }
}
```

### 9. è°ƒè¯•å’Œè¯Šæ–­å¢å¼º

#### è°ƒç”¨æ–¹ä¿¡æ¯å¢å¼º
```csharp
// C# 14 è°ƒç”¨æ–¹ä¿¡æ¯å¢å¼º
public class Logger
{
    public void LogInfo(string message, 
        [CallerFilePath] string filePath = "",
        [CallerLineNumber] int lineNumber = 0,
        [CallerMemberName] string memberName = "")
    {
        var fileName = Path.GetFileName(filePath);
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] {fileName}:{lineNumber} {memberName} - {message}");
    }
}

// ä½¿ç”¨
var logger = new Logger();
logger.LogInfo("å¤„ç†å®Œæˆ"); // è‡ªåŠ¨åŒ…å«è°ƒç”¨ä¿¡æ¯
```

### 10. æ€»ç»“

C# 14 çš„æ–°ç‰¹æ€§ä¸º .NET 10 + Avalonia UI å¼€å‘å¸¦æ¥äº†ï¼š

1. **é›†åˆè¡¨è¾¾å¼**ï¼šæ›´ç®€æ´çš„é›†åˆåˆå§‹åŒ–è¯­æ³•
2. **æ¨¡å¼åŒ¹é…å¢å¼º**ï¼šåˆ—è¡¨æ¨¡å¼ã€åˆ‡ç‰‡æ¨¡å¼ç­‰
3. **å¿…éœ€æˆå‘˜**ï¼šæ›´å¥½çš„å¯¹è±¡åˆå§‹åŒ–æ§åˆ¶
4. **æ–‡ä»¶æœ¬åœ°ç±»å‹**ï¼šé¿å…å‘½åå†²çª
5. **é™æ€æŠ½è±¡æˆå‘˜**ï¼šæ›´å¼ºå¤§çš„æ³›å‹çº¦æŸ
6. **å¼‚æ­¥æµå¢å¼º**ï¼šæ›´å¥½çš„å¼‚æ­¥æ•°æ®å¤„ç†
7. **ç©ºå€¼å¤„ç†**ï¼šæ›´å®‰å…¨çš„ç©ºå€¼æ“ä½œ
8. **æ€§èƒ½ä¼˜åŒ–**ï¼šSpan<T>ã€Memory<T> ç­‰é«˜æ€§èƒ½ç±»å‹
9. **è®°å½•ç±»å‹**ï¼šä¸å¯å˜æ•°æ®ç±»å‹çš„ç®€åŒ–
10. **ç°ä»£å¼‚æ­¥æ¨¡å¼**ï¼šæ›´å¥½çš„å¼‚æ­¥ç¼–ç¨‹ä½“éªŒ

è¿™äº›æ–°ç‰¹æ€§è®©ä»£ç æ›´åŠ ç®€æ´ã€å®‰å…¨ã€é«˜æ•ˆï¼Œç‰¹åˆ«é€‚åˆç°ä»£æ¡Œé¢åº”ç”¨å¼€å‘ï¼

---

## ğŸš€ æ‰¹é‡å¤„ç†åŠŸèƒ½æ¶æ„è®¾è®¡

### 1. åŠŸèƒ½æ¦‚è¿°

æ‰¹é‡å¤„ç†åŠŸèƒ½æ˜¯å¯¹åŸæœ‰å•æ–‡ä»¶å¤„ç†èƒ½åŠ›çš„æ‰©å±•ï¼Œå…è®¸ç”¨æˆ·é€‰æ‹©æ•´ä¸ªæ–‡ä»¶å¤¹è¿›è¡Œæ‰¹é‡åˆ†æï¼Œå¤§å¤§æé«˜äº†å¤„ç†æ•ˆç‡ã€‚

#### æ ¸å¿ƒåŠŸèƒ½ç‰¹æ€§
- **ğŸ“ æ–‡ä»¶å¤¹é€‰æ‹©**ï¼šæ”¯æŒé€‰æ‹©åŒ…å«å¤šä¸ªtxtæ–‡ä»¶çš„æ–‡ä»¶å¤¹
- **ğŸ”„ é€’å½’æ‰«æ**ï¼šè‡ªåŠ¨æ‰«æå­æ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰txtæ–‡ä»¶
- **ğŸ“Š æ‰¹é‡å¤„ç†**ï¼šå¼‚æ­¥å¤„ç†å¤šä¸ªæ–‡ä»¶ï¼Œä¸é˜»å¡UI
- **ğŸ“ˆ è¿›åº¦åé¦ˆ**ï¼šå®æ—¶æ˜¾ç¤ºå¤„ç†è¿›åº¦å’Œå½“å‰çŠ¶æ€
- **ğŸ”— æ•°æ®åˆå¹¶**ï¼šæ™ºèƒ½åˆå¹¶æ¥è‡ªä¸åŒæ–‡ä»¶çš„æ ‡ç­¾ç»Ÿè®¡
- **ğŸ“„ æ¥æºè¿½è¸ª**ï¼šè®°å½•æ¯ä¸ªæ ‡ç­¾æ¥è‡ªå“ªäº›æ–‡ä»¶å’ŒID

### 2. æ¶æ„è®¾è®¡

#### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ‰¹é‡å¤„ç†æ¶æ„è®¾è®¡                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Presentation Layer (è¡¨ç¤ºå±‚)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   MainWindow    â”‚  â”‚   ProgressBar   â”‚  â”‚   StatusUI   â”‚ â”‚
â”‚  â”‚   (ä¸»ç•Œé¢)       â”‚  â”‚   (è¿›åº¦æ¡)      â”‚  â”‚   (çŠ¶æ€æ˜¾ç¤º)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Business Logic Layer (ä¸šåŠ¡é€»è¾‘å±‚)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ MainWindowVM    â”‚  â”‚ BatchProcessor  â”‚  â”‚ DataMerger   â”‚ â”‚
â”‚  â”‚ (ä¸»è§†å›¾æ¨¡å‹)     â”‚  â”‚ (æ‰¹é‡å¤„ç†å™¨)    â”‚  â”‚ (æ•°æ®åˆå¹¶å™¨)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Access Layer (æ•°æ®è®¿é—®å±‚)                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   FileScanner   â”‚  â”‚   TextParser    â”‚  â”‚   TagInfo    â”‚ â”‚
â”‚  â”‚   (æ–‡ä»¶æ‰«æå™¨)   â”‚  â”‚   (æ–‡æœ¬è§£æå™¨)   â”‚  â”‚   (æ ‡ç­¾ä¿¡æ¯)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Infrastructure Layer (åŸºç¡€è®¾æ–½å±‚)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   FileSystem    â”‚  â”‚   Async/Await   â”‚  â”‚   Progress   â”‚ â”‚
â”‚  â”‚   (æ–‡ä»¶ç³»ç»Ÿ)     â”‚  â”‚   (å¼‚æ­¥å¤„ç†)    â”‚  â”‚   (è¿›åº¦è·Ÿè¸ª)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ•°æ®æµè®¾è®¡

```
æ–‡ä»¶å¤¹é€‰æ‹© â†’ æ–‡ä»¶æ‰«æ â†’ å¼‚æ­¥å¤„ç† â†’ æ•°æ®åˆå¹¶ â†’ UIæ›´æ–°
     â†“           â†“          â†“         â†“        â†“
  ç”¨æˆ·æ“ä½œ   é€’å½’æ‰«æ    å¹¶è¡Œè§£æ    æ™ºèƒ½åˆå¹¶   å®æ—¶åé¦ˆ
     â†“           â†“          â†“         â†“        â†“
  æ–‡ä»¶å¤¹è·¯å¾„  .txtæ–‡ä»¶åˆ—è¡¨  æ ‡ç­¾æ•°æ®   åˆå¹¶ç»“æœ   è¿›åº¦æ˜¾ç¤º
```

### 3. æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 3.1 ViewModel å±‚æ‰©å±•

```csharp
// ViewModels/MainWindowViewModel.cs - æ‰¹é‡å¤„ç†æ‰©å±•
public class MainWindowViewModel : INotifyPropertyChanged
{
    // åŸºç¡€å±æ€§
    private ObservableCollection<TagInfoViewModel> _tagInfos = new();
    private string _statusMessage = "è¯·é€‰æ‹©æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹è¿›è¡Œåˆ†æ";
    private bool _isProcessing = false;
    
    // æ‰¹é‡å¤„ç†ä¸“ç”¨å±æ€§
    private int _processedFiles = 0;
    private int _totalFiles = 0;
    private string _currentProcessingFile = string.Empty;
    private DateTime _startTime = DateTime.Now;
    
    // è®¡ç®—å±æ€§ - C# 14 ç‰¹æ€§
    public string ProgressMessage
    {
        get
        {
            if (_totalFiles > 0)
            {
                var percentage = _processedFiles * 100.0 / _totalFiles;
                return $"è¿›åº¦: {_processedFiles}/{_totalFiles} ({percentage:F1}%)";
            }
            return string.Empty;
        }
    }
    
    public string ProcessingSpeed
    {
        get
        {
            if (_processedFiles > 0 && _isProcessing)
            {
                var elapsed = DateTime.Now - _startTime;
                var speed = _processedFiles / elapsed.TotalSeconds;
                return $"å¤„ç†é€Ÿåº¦: {speed:F1} æ–‡ä»¶/ç§’";
            }
            return string.Empty;
        }
    }
    
    // æ‰¹é‡å¤„ç†æ ¸å¿ƒæ–¹æ³•
    public async Task ProcessFolderAsync(string folderPath)
    {
        IsProcessing = true;
        StartTime = DateTime.Now;
        StatusMessage = "æ­£åœ¨æ‰«ææ–‡ä»¶å¤¹...";
        ProcessedFiles = 0;
        TotalFiles = 0;
        CurrentProcessingFile = string.Empty;

        try
        {
            // 1. æ–‡ä»¶æ‰«æé˜¶æ®µ
            var txtFiles = await ScanTxtFilesAsync(folderPath);
            TotalFiles = txtFiles.Length;

            if (TotalFiles == 0)
            {
                StatusMessage = "æ–‡ä»¶å¤¹ä¸­æ²¡æœ‰æ‰¾åˆ°txtæ–‡ä»¶";
                return;
            }

            StatusMessage = $"æ‰¾åˆ° {TotalFiles} ä¸ªtxtæ–‡ä»¶ï¼Œå¼€å§‹æ‰¹é‡å¤„ç†...";

            // 2. æ•°æ®åˆå¹¶å®¹å™¨ - ä½¿ç”¨ C# 14 é›†åˆè¡¨è¾¾å¼
            var allTagInfos = new Dictionary<string, TagInfoViewModel>();

            // 3. é€ä¸ªæ–‡ä»¶å¤„ç†
            foreach (var filePath in txtFiles)
            {
                try
                {
                    CurrentProcessingFile = Path.GetFileName(filePath);
                    StatusMessage = $"æ­£åœ¨å¤„ç†: {CurrentProcessingFile}";

                    var content = await File.ReadAllTextAsync(filePath);
                    var results = TextParser.ParseText(content);

                    // åˆå¹¶ç»“æœåˆ°æ€»å®¹å™¨
                    MergeResults(allTagInfos, results, filePath);
                }
                catch (Exception ex)
                {
                    StatusMessage = $"å¤„ç†æ–‡ä»¶ {Path.GetFileName(filePath)} å¤±è´¥: {ex.Message}";
                }

                ProcessedFiles++;
            }

            // 4. æ›´æ–°UIæ˜¾ç¤º
            UpdateUIWithResults(allTagInfos);
            StatusMessage = $"æ‰¹é‡å¤„ç†å®Œæˆï¼å…±å¤„ç† {ProcessedFiles} ä¸ªæ–‡ä»¶ï¼Œæ‰¾åˆ° {allTagInfos.Count} ä¸ªä¸åŒçš„æ ‡ç­¾";
        }
        catch (Exception ex)
        {
            StatusMessage = $"æ‰¹é‡å¤„ç†å¤±è´¥ï¼š{ex.Message}";
        }
        finally
        {
            IsProcessing = false;
            CurrentProcessingFile = string.Empty;
        }
    }
}
```

#### 3.2 æ•°æ®åˆå¹¶ç®—æ³•

```csharp
// æ™ºèƒ½æ•°æ®åˆå¹¶æ–¹æ³• - ä½¿ç”¨ C# 14 æ¨¡å¼åŒ¹é…
private void MergeResults(Dictionary<string, TagInfoViewModel> allTagInfos, 
                         List<TagInfo> results, string filePath)
{
    foreach (var result in results)
    {
        // ä½¿ç”¨æ¨¡å¼åŒ¹é…å¤„ç†ä¸åŒæƒ…å†µ
        var tagInfo = result switch
        {
            { Tag: var tag, Count: > 0 } when !string.IsNullOrEmpty(tag) =>
                GetOrCreateTagInfo(allTagInfos, tag),
            _ => null
        };
        
        if (tagInfo != null)
        {
            tagInfo.Count += result.Count;
            MergeSourceIds(tagInfo, result.SourceIds);
            MergeSourceFiles(tagInfo, filePath);
        }
    }
}

// è·å–æˆ–åˆ›å»ºæ ‡ç­¾ä¿¡æ¯
private TagInfoViewModel GetOrCreateTagInfo(Dictionary<string, TagInfoViewModel> allTagInfos, string tag)
{
    if (!allTagInfos.ContainsKey(tag))
    {
        allTagInfos[tag] = new TagInfoViewModel
        {
            Tag = tag,
            Count = 0,
            SourceIds = string.Empty,
            SourceFiles = string.Empty
        };
    }
    return allTagInfos[tag];
}

// åˆå¹¶æ¥æºID - ä½¿ç”¨ C# 14 é›†åˆè¡¨è¾¾å¼
private void MergeSourceIds(TagInfoViewModel tagInfo, List<string> newIds)
{
    if (string.IsNullOrEmpty(tagInfo.SourceIds))
    {
        tagInfo.SourceIds = string.Join(", ", newIds);
    }
    else
    {
        var existingIds = tagInfo.SourceIds.Split(", ", StringSplitOptions.RemoveEmptyEntries).ToList();
        existingIds.AddRange(newIds);
        tagInfo.SourceIds = string.Join(", ", existingIds.Distinct());
    }
}

// åˆå¹¶æ¥æºæ–‡ä»¶
private void MergeSourceFiles(TagInfoViewModel tagInfo, string filePath)
{
    var fileName = Path.GetFileName(filePath);
    if (string.IsNullOrEmpty(tagInfo.SourceFiles))
    {
        tagInfo.SourceFiles = fileName;
    }
    else if (!tagInfo.SourceFiles.Contains(fileName))
    {
        tagInfo.SourceFiles += $", {fileName}";
    }
}
```

#### 3.3 View å±‚å®ç°

```xml
<!-- MainWindow.axaml - æ‰¹é‡å¤„ç†UI -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:TagAnalyzer.ViewModels"
        x:Class="TagAnalyzer.MainWindow"
        x:DataType="vm:MainWindowViewModel"
        Title="æ ‡ç­¾åˆ†æå·¥å…· - æ‰¹é‡å¤„ç†ç‰ˆ - jiashuai_xu@qq.com"
        Width="1000" Height="800"
        MinWidth="800" MinHeight="600">

    <Grid RowDefinitions="Auto,*,Auto">
        <!-- å·¥å…·æ  -->
        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="10" Spacing="10">
            <Button Name="SelectFileButton" Content="é€‰æ‹©æ–‡ä»¶" 
                    Click="SelectFileButton_Click"
                    IsEnabled="{Binding !IsProcessing}"
                    Classes="accent"/>
            <Button Name="SelectFolderButton" Content="é€‰æ‹©æ–‡ä»¶å¤¹" 
                    Click="SelectFolderButton_Click"
                    IsEnabled="{Binding !IsProcessing}"
                    Classes="accent"/>
            <Button Name="ExportCsvButton" Content="å¯¼å‡ºCSV" 
                    Click="ExportCsvButton_Click"
                    Classes="outline"/>
            <Button Name="ClearButton" Content="æ¸…ç©ºç»“æœ" 
                    Click="ClearButton_Click"
                    Classes="outline"/>
        </StackPanel>

        <!-- ä¸»å†…å®¹åŒºåŸŸ -->
        <Grid Grid.Row="1" Margin="10">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>

            <!-- çŠ¶æ€ä¿¡æ¯åŒºåŸŸ -->
            <StackPanel Grid.Row="0" Margin="0,0,0,10">
                <!-- ä¸»çŠ¶æ€ä¿¡æ¯ -->
                <TextBlock Text="{Binding StatusMessage}" 
                           FontSize="14" 
                           Foreground="{DynamicResource SystemAccentColor}"/>
                
                <!-- è¿›åº¦ä¿¡æ¯ -->
                <StackPanel Orientation="Horizontal" Margin="0,5,0,0" 
                            IsVisible="{Binding TotalFiles}">
                    <TextBlock Text="{Binding ProgressMessage}" 
                               FontSize="12" 
                               Foreground="{DynamicResource SystemBaseMediumColor}"/>
                    <TextBlock Text="{Binding CurrentProcessingFile, StringFormat=' | å½“å‰: {0}'}" 
                               FontSize="12" 
                               Foreground="{DynamicResource SystemBaseMediumColor}"
                               Margin="10,0,0,0"/>
                </StackPanel>
                
                <!-- å¤„ç†é€Ÿåº¦ -->
                <TextBlock Text="{Binding ProcessingSpeed}" 
                           FontSize="11" 
                           Foreground="{DynamicResource SystemBaseMediumColor}"
                           Margin="0,2,0,0"
                           IsVisible="{Binding IsProcessing}"/>
                
                <!-- è¿›åº¦æ¡ -->
                <ProgressBar Value="{Binding ProcessedFiles}" 
                             Maximum="{Binding TotalFiles}"
                             IsVisible="{Binding TotalFiles}"
                             Margin="0,5,0,0"/>
            </StackPanel>

            <!-- æ•°æ®è¡¨æ ¼ -->
            <ListBox Grid.Row="1" 
                     ItemsSource="{Binding TagInfos}"
                     ScrollViewer.HorizontalScrollBarVisibility="Auto"
                     ScrollViewer.VerticalScrollBarVisibility="Auto">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <Grid Margin="5">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="120"/>
                                <ColumnDefinition Width="80"/>
                                <ColumnDefinition Width="200"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>
                            <TextBlock Grid.Column="0" Text="{Binding Tag}" FontWeight="Bold"/>
                            <TextBlock Grid.Column="1" Text="{Binding Count}" HorizontalAlignment="Center"/>
                            <TextBlock Grid.Column="2" Text="{Binding SourceIds}" TextWrapping="Wrap" FontSize="11"/>
                            <TextBlock Grid.Column="3" Text="{Binding SourceFiles}" TextWrapping="Wrap" FontSize="11" 
                                       Foreground="{DynamicResource SystemBaseMediumColor}"/>
                        </Grid>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>
        </Grid>

        <!-- åº•éƒ¨çŠ¶æ€æ  -->
        <Border Grid.Row="2" Background="{DynamicResource SystemControlBackgroundBaseLowBrush}" 
                Padding="10,5">
            <TextBlock Text="å¼€å‘è€…: jiashuai_xu@qq.com | ç‰ˆæœ¬: 1.0.0 | æ”¯æŒæ‰¹é‡å¤„ç†" 
                       HorizontalAlignment="Right"/>
        </Border>
    </Grid>
</Window>
```

### 4. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 4.1 å†…å­˜ä¼˜åŒ–

```csharp
// å†…å­˜ä¼˜åŒ–çš„æ‰¹é‡å¤„ç†
public class MemoryOptimizedProcessor
{
    private const int MaxMemoryFiles = 100;
    
    public async Task ProcessLargeFolderAsync(string folderPath)
    {
        var files = Directory.GetFiles(folderPath, "*.txt", SearchOption.AllDirectories);
        
        if (files.Length > MaxMemoryFiles)
        {
            await ProcessInBatches(files);
        }
        else
        {
            await ProcessDirectly(files);
        }
    }
    
    private async Task ProcessInBatches(string[] files)
    {
        var batchSize = MaxMemoryFiles;
        var allResults = new Dictionary<string, TagInfoViewModel>();
        
        for (int i = 0; i < files.Length; i += batchSize)
        {
            var batch = files.Skip(i).Take(batchSize);
            var batchResults = await ProcessBatch(batch);
            
            MergeBatchResults(allResults, batchResults);
            
            // å¼ºåˆ¶åƒåœ¾å›æ”¶
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }
        
        UpdateUIWithResults(allResults);
    }
}
```

#### 4.2 å¹¶å‘ä¼˜åŒ–

```csharp
// å¹¶å‘å¤„ç†ä¼˜åŒ–
public class ConcurrentProcessor
{
    private readonly SemaphoreSlim _semaphore;
    
    public ConcurrentProcessor(int maxConcurrency = 4)
    {
        _semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency);
    }
    
    public async Task<List<TagInfoViewModel>> ProcessConcurrentlyAsync(
        IEnumerable<string> filePaths)
    {
        var tasks = filePaths.Select(filePath => ProcessFileWithSemaphore(filePath));
        var results = await Task.WhenAll(tasks);
        
        // åˆå¹¶æ‰€æœ‰ç»“æœ
        var mergedResults = new Dictionary<string, TagInfoViewModel>();
        foreach (var result in results.Where(r => r != null))
        {
            MergeResults(mergedResults, result);
        }
        
        return mergedResults.Values.ToList();
    }
    
    private async Task<TagInfoViewModel?> ProcessFileWithSemaphore(string filePath)
    {
        await _semaphore.WaitAsync();
        try
        {
            return await ProcessSingleFile(filePath);
        }
        finally
        {
            _semaphore.Release();
        }
    }
}
```

### 5. é”™è¯¯å¤„ç†æœºåˆ¶

#### 5.1 åˆ†å±‚é”™è¯¯å¤„ç†

```csharp
// åˆ†å±‚é”™è¯¯å¤„ç†ç­–ç•¥
public class ErrorHandler
{
    public async Task<ProcessResult> ProcessWithErrorHandling(string folderPath)
    {
        try
        {
            // 1. å‚æ•°éªŒè¯
            ValidateInput(folderPath);
            
            // 2. æ–‡ä»¶æ‰«æ
            var files = await ScanFiles(folderPath);
            
            // 3. æ‰¹é‡å¤„ç†
            var results = await ProcessFiles(files);
            
            return ProcessResult.Success(results);
        }
        catch (ArgumentException ex)
        {
            return ProcessResult.Error($"å‚æ•°é”™è¯¯: {ex.Message}");
        }
        catch (DirectoryNotFoundException ex)
        {
            return ProcessResult.Error($"æ–‡ä»¶å¤¹ä¸å­˜åœ¨: {ex.Message}");
        }
        catch (UnauthorizedAccessException ex)
        {
            return ProcessResult.Error($"è®¿é—®æƒé™ä¸è¶³: {ex.Message}");
        }
        catch (IOException ex)
        {
            return ProcessResult.Error($"æ–‡ä»¶æ“ä½œå¤±è´¥: {ex.Message}");
        }
        catch (Exception ex)
        {
            return ProcessResult.Error($"æœªçŸ¥é”™è¯¯: {ex.Message}");
        }
    }
}
```

#### 5.2 æ–‡ä»¶çº§é”™è¯¯å¤„ç†

```csharp
// å•ä¸ªæ–‡ä»¶é”™è¯¯å¤„ç†
public async Task<FileProcessResult> ProcessSingleFileAsync(string filePath)
{
    try
    {
        // æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥
        if (!File.Exists(filePath))
        {
            return FileProcessResult.Error($"æ–‡ä»¶ä¸å­˜åœ¨: {filePath}");
        }
        
        // æ–‡ä»¶å¤§å°æ£€æŸ¥
        var fileInfo = new FileInfo(filePath);
        if (fileInfo.Length == 0)
        {
            return FileProcessResult.Error($"æ–‡ä»¶ä¸ºç©º: {filePath}");
        }
        
        if (fileInfo.Length > 50 * 1024 * 1024) // 50MB
        {
            return FileProcessResult.Error($"æ–‡ä»¶è¿‡å¤§: {filePath}");
        }
        
        // è¯»å–å’Œå¤„ç†æ–‡ä»¶
        var content = await File.ReadAllTextAsync(filePath);
        var tags = TextParser.ParseText(content);
        
        return FileProcessResult.Success(filePath, tags);
    }
    catch (UnauthorizedAccessException)
    {
        return FileProcessResult.Error($"æ²¡æœ‰è¯»å–æƒé™: {filePath}");
    }
    catch (IOException ex)
    {
        return FileProcessResult.Error($"æ–‡ä»¶è¯»å–å¤±è´¥: {filePath}, é”™è¯¯: {ex.Message}");
    }
    catch (Exception ex)
    {
        return FileProcessResult.Error($"å¤„ç†æ–‡ä»¶å¤±è´¥: {filePath}, é”™è¯¯: {ex.Message}");
    }
}
```

### 6. æµ‹è¯•ç­–ç•¥

#### 6.1 å•å…ƒæµ‹è¯•

```csharp
// æ‰¹é‡å¤„ç†åŠŸèƒ½æµ‹è¯•
[TestClass]
public class BatchProcessingTests
{
    private string _testFolderPath = string.Empty;
    
    [TestInitialize]
    public void Setup()
    {
        _testFolderPath = Path.Combine(Path.GetTempPath(), "TagAnalyzerTest");
        Directory.CreateDirectory(_testFolderPath);
        
        // åˆ›å»ºæµ‹è¯•æ–‡ä»¶
        CreateTestFiles();
    }
    
    [TestCleanup]
    public void Cleanup()
    {
        if (Directory.Exists(_testFolderPath))
        {
            Directory.Delete(_testFolderPath, true);
        }
    }
    
    [TestMethod]
    public async Task ProcessFolderAsync_ShouldMergeResultsCorrectly()
    {
        // Arrange
        var viewModel = new MainWindowViewModel();
        
        // Act
        await viewModel.ProcessFolderAsync(_testFolderPath);
        
        // Assert
        Assert.IsTrue(viewModel.TagInfos.Count > 0);
        
        var tagInfo = viewModel.TagInfos.FirstOrDefault(t => t.Tag == "æŠ½æ³£");
        Assert.IsNotNull(tagInfo);
        Assert.AreEqual(3, tagInfo.Count); // åº”è¯¥åˆå¹¶3ä¸ªæ–‡ä»¶ä¸­çš„æŠ½æ³£æ ‡ç­¾
        Assert.IsTrue(tagInfo.SourceFiles.Contains("file1.txt"));
        Assert.IsTrue(tagInfo.SourceFiles.Contains("file2.txt"));
        Assert.IsTrue(tagInfo.SourceFiles.Contains("file3.txt"));
    }
    
    [TestMethod]
    public async Task ProcessFolderAsync_ShouldHandleEmptyFolder()
    {
        // Arrange
        var emptyFolder = Path.Combine(_testFolderPath, "empty");
        Directory.CreateDirectory(emptyFolder);
        var viewModel = new MainWindowViewModel();
        
        // Act
        await viewModel.ProcessFolderAsync(emptyFolder);
        
        // Assert
        Assert.AreEqual("æ–‡ä»¶å¤¹ä¸­æ²¡æœ‰æ‰¾åˆ°txtæ–‡ä»¶", viewModel.StatusMessage);
        Assert.AreEqual(0, viewModel.TagInfos.Count);
    }
    
    private void CreateTestFiles()
    {
        // åˆ›å»ºæµ‹è¯•æ–‡ä»¶
        File.WriteAllText(Path.Combine(_testFolderPath, "file1.txt"), 
            "M35_230001ã€æŠ½æ³£ã€‘ç¬¬ä¸€ä¸ªæ–‡ä»¶\nM35_230002ã€å¹æ°”ã€‘");
        
        File.WriteAllText(Path.Combine(_testFolderPath, "file2.txt"), 
            "M35_230003ã€æŠ½æ³£ã€‘ç¬¬äºŒä¸ªæ–‡ä»¶\nM35_230004ã€æ–°æ ‡ç­¾ã€‘");
        
        File.WriteAllText(Path.Combine(_testFolderPath, "file3.txt"), 
            "M35_230005ã€æŠ½æ³£ã€‘ç¬¬ä¸‰ä¸ªæ–‡ä»¶\nM35_230006ã€ç‹¬ç‰¹æ ‡ç­¾ã€‘");
    }
}
```

#### 6.2 æ€§èƒ½æµ‹è¯•

```csharp
// æ€§èƒ½æµ‹è¯•
[TestClass]
public class PerformanceTests
{
    [TestMethod]
    public async Task ProcessLargeFolder_ShouldCompleteWithinTimeLimit()
    {
        // Arrange
        var largeFolder = CreateLargeTestFolder(1000); // 1000ä¸ªæ–‡ä»¶
        var viewModel = new MainWindowViewModel();
        var stopwatch = Stopwatch.StartNew();
        
        // Act
        await viewModel.ProcessFolderAsync(largeFolder);
        stopwatch.Stop();
        
        // Assert
        Assert.IsTrue(stopwatch.ElapsedMilliseconds < 30000); // 30ç§’å†…å®Œæˆ
        Assert.IsTrue(viewModel.TagInfos.Count > 0);
        
        // Cleanup
        Directory.Delete(largeFolder, true);
    }
    
    [TestMethod]
    public async Task MemoryUsage_ShouldRemainStable()
    {
        // Arrange
        var folder = CreateLargeTestFolder(500);
        var viewModel = new MainWindowViewModel();
        
        // Act
        var initialMemory = GC.GetTotalMemory(true);
        await viewModel.ProcessFolderAsync(folder);
        var finalMemory = GC.GetTotalMemory(true);
        
        // Assert
        var memoryIncrease = finalMemory - initialMemory;
        Assert.IsTrue(memoryIncrease < 100 * 1024 * 1024); // å†…å­˜å¢é•¿å°äº100MB
        
        // Cleanup
        Directory.Delete(folder, true);
    }
    
    private string CreateLargeTestFolder(int fileCount)
    {
        var folder = Path.Combine(Path.GetTempPath(), "LargeTestFolder");
        Directory.CreateDirectory(folder);
        
        for (int i = 0; i < fileCount; i++)
        {
            var content = $"M35_{i:D6}ã€æ ‡ç­¾{i % 10}ã€‘æµ‹è¯•å†…å®¹\nM35_{i + 1:D6}ã€å¦ä¸€ä¸ªæ ‡ç­¾ã€‘";
            File.WriteAllText(Path.Combine(folder, $"file{i}.txt"), content);
        }
        
        return folder;
    }
}
```

### 7. æ€»ç»“

æ‰¹é‡å¤„ç†åŠŸèƒ½æ¶æ„è®¾è®¡çš„å…³é”®è¦ç‚¹ï¼š

1. **æ¶æ„åˆ†å±‚**ï¼šæ¸…æ™°çš„èŒè´£åˆ†ç¦»ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
2. **å¼‚æ­¥å¤„ç†**ï¼šä¸é˜»å¡UIçº¿ç¨‹ï¼Œæä¾›è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒ
3. **æ•°æ®åˆå¹¶**ï¼šæ™ºèƒ½åˆå¹¶æ¥è‡ªä¸åŒæ–‡ä»¶çš„æ ‡ç­¾ç»Ÿè®¡
4. **è¿›åº¦åé¦ˆ**ï¼šå®æ—¶æ˜¾ç¤ºå¤„ç†è¿›åº¦å’ŒçŠ¶æ€ä¿¡æ¯
5. **é”™è¯¯å¤„ç†**ï¼šåˆ†å±‚å¼‚å¸¸å¤„ç†ï¼Œä¼˜é›…é™çº§
6. **æ€§èƒ½ä¼˜åŒ–**ï¼šå†…å­˜ç®¡ç†ã€å¹¶å‘å¤„ç†ã€èµ„æºæ¸…ç†
7. **æµ‹è¯•è¦†ç›–**ï¼šå•å…ƒæµ‹è¯•å’Œæ€§èƒ½æµ‹è¯•ç¡®ä¿è´¨é‡
8. **C# 14 ç‰¹æ€§**ï¼šå……åˆ†åˆ©ç”¨ç°ä»£è¯­æ³•ç‰¹æ€§æå‡ä»£ç è´¨é‡

è¿™å¥—æ¶æ„ä¸ºå¤„ç†å¤§é‡æ–‡ä»¶æä¾›äº†é«˜æ•ˆã€ç¨³å®šã€ç”¨æˆ·å‹å¥½çš„è§£å†³æ–¹æ¡ˆï¼Œå±•ç°äº†ç°ä»£ .NET 10 + C# 14 å¼€å‘çš„æœ€ä½³å®è·µï¼
